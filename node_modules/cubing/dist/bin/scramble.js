#!/usr/bin/env -S node --
import {
  packageVersion
} from "./chunks/chunk-WFE2REKW.js";

// src/bin/scramble.ts
import { basename } from "node:path";
import { argv } from "node:process";
import {
  argument,
  choice,
  integer,
  map,
  merge,
  message,
  object,
  option,
  withDefault
} from "@optique/core";
import { run } from "@optique/run";
import { eventInfo, twizzleEvents } from "cubing/puzzles";
import { randomScrambleForEvent } from "cubing/scramble";
import { setSearchDebug } from "cubing/search";
var outputFormats = ["auto", "text", "link", "json-text"];
var notationTypes = ["auto", "LGN"];
var eventIDs = Object.entries(twizzleEvents).filter(([_, eventInfo2]) => !!eventInfo2.scramblesImplemented).map(([eventID2, _]) => eventID2);
var args = run(
  merge(
    object({
      amount: withDefault(
        option("--amount", "-n", integer({ metavar: "AMOUNT", min: 1 }), {
          description: message`Amount of scrambles.`
        }),
        1
      ),
      notation: withDefault(
        option("--notation", choice(notationTypes, { metavar: "NOTATION" })),
        "auto"
      )
    }),
    object({
      format: withDefault(
        option("--format", "-f", choice(outputFormats, { metavar: "FORMAT" })),
        "auto"
      )
    }),
    object({
      // TODO: consolidate this with `format`: https://github.com/dahlia/optique/issues/57
      text: map(
        option("--text", "-t", {
          description: message`Convenient shorthand for \`--format text\`.`
        }),
        () => "text"
      )
    }),
    object({
      eventID: argument(choice(eventIDs, { metavar: "EVENT_ID" }), {
        description: message`WCA or unoffiical event ID.`
      })
    })
  ),
  {
    programName: basename(argv[1]),
    description: message`Example: order 3x3x3 "R U R' U R U2' R'"`,
    help: "option",
    completion: {
      mode: "option",
      name: "plural"
    },
    version: {
      mode: "option",
      value: packageVersion
    }
  }
);
var { amount, format: argsFormat, notation, text, eventID } = args;
var format = argsFormat ?? text ?? (!process.stdout.isTTY ? "text" : "auto");
setSearchDebug({ logPerf: false, showWorkerInstantiationWarnings: false });
function scrambleText(scramble) {
  return scramble.toString({
    // TODO: any
    notation
    // TODO: handle type conversion at arg parse time.
  });
}
function scrambleLink(scramble) {
  const url = new URL("https://alpha.twizzle.net/edit/");
  const puzzleID = eventInfo(eventID)?.puzzleID;
  puzzleID && url.searchParams.set("puzzle", puzzleID);
  url.searchParams.set("alg", scrambleText(scramble));
  return url.toString();
}
var JSONListPrinter = class {
  #finished = false;
  #firstValuePrintedAlready = false;
  constructor() {
    process.stdout.write("[\n  ");
  }
  push(value) {
    if (this.#firstValuePrintedAlready) {
      process.stdout.write(",\n  ");
    }
    this.#firstValuePrintedAlready = true;
    process.stdout.write(JSON.stringify(value));
  }
  finish() {
    if (this.#finished) {
      throw new Error("Tried to finish JSON list printing multiple times.");
    }
    this.#finished = true;
    console.log("\n]");
  }
};
function nodeForgetTopLevelAwaitWorkaround(_promise) {
  return Promise.resolve();
}
await nodeForgetTopLevelAwaitWorkaround(
  (async () => {
    if (format !== "json-text" && amount === 1) {
      const scramble = await randomScrambleForEvent(eventID);
      switch (format) {
        case "auto": {
          console.log(`${scrambleText(scramble)}

\u{1F517} ${scrambleLink(scramble)}`);
          break;
        }
        case "text": {
          console.log(scrambleText(scramble));
          break;
        }
        case "link": {
          console.log(scrambleLink(scramble));
          break;
        }
        // @ts-expect-error This is a code guard for future refactoring.
        case "json-text": {
          throw new Error(
            "Encountered `json` format in code that is not expected to handle it."
          );
        }
        default: {
          throw new Error("Invalid format!");
        }
      }
    } else {
      const jsonListPrinter = format === "json-text" ? new JSONListPrinter() : void 0;
      for (let i = 0; i < amount; i++) {
        const scramble = await randomScrambleForEvent(eventID);
        switch (format) {
          case "auto": {
            console.log(`// Scramble #${i + 1}
${scrambleText(scramble)}

\u{1F517} ${scrambleLink(scramble)}
`);
            break;
          }
          case "text": {
            console.log(`// Scramble #${i + 1}`);
            console.log(`${scrambleText(scramble)}
`);
            break;
          }
          case "link": {
            console.log(`// Scramble #${i + 1}`);
            console.log(`${scrambleLink(scramble)}
`);
            break;
          }
          case "json-text": {
            jsonListPrinter?.push(scramble.toString());
            break;
          }
          default: {
            throw new Error("Invalid format!");
          }
        }
      }
      jsonListPrinter?.finish();
    }
  })()
);
//# sourceMappingURL=scramble.js.map
