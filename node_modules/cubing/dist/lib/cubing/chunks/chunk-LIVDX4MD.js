import {
  exposeAPI
} from "./chunk-7GUL3OBQ.js";
import {
  node_adapter_default
} from "./chunk-XO3JAA3V.js";
import {
  Alg
} from "./chunk-O6HEZXGY.js";

// src/cubing/vendor/apache/comlink-everywhere/outside/index.ts
import { wrap } from "comlink";
var useNodeWorkarounds = typeof globalThis.Worker === "undefined" && typeof globalThis.WorkerNavigator === "undefined";
async function nodeWorker(source, options) {
  const { Worker: NodeWorker } = globalThis.process.getBuiltinModule(
    "node:worker_threads"
  );
  const worker = new NodeWorker(source, options);
  return node_adapter_default(worker);
}
async function constructWorker(source, options) {
  let worker;
  if (useNodeWorkarounds) {
    return nodeWorker(source);
  } else {
    worker = new globalThis.Worker(source, {
      type: options ? options.type : void 0
      // TODO: Is it safe to use `options?.type`?
    });
  }
  return worker;
}

// src/cubing/search/worker-workarounds/index.ts
function searchWorkerURLImportMetaResolve() {
  return import.meta.resolve("./search-worker-entry.js");
}
function searchWorkerURLNewURLImportMetaURL() {
  return new URL("./search-worker-entry.js", import.meta.url);
}
async function searchWorkerURLEsbuildWorkaround() {
  exposeAPI.expose = false;
  return (await import("./search-worker-entry.js")).WORKER_ENTRY_FILE_URL;
}
function instantiateSearchWorkerURLNewURLImportMetaURL() {
  return new Worker(new URL("./search-worker-entry.js", import.meta.url), {
    type: "module"
  });
}

// src/cubing/search/instantiator.ts
function probablyCrossOrigin(workerEntryFileURL) {
  try {
    const scriptOrigin = globalThis.location?.origin;
    const workerOrigin = workerEntryFileURL.origin;
    return !!scriptOrigin && !!workerOrigin && scriptOrigin !== workerOrigin;
  } catch {
    return false;
  }
}
async function instantiateModuleWorker(workerEntryFileURL) {
  const url = new URL(workerEntryFileURL, import.meta.url);
  const tryTrampolineFirst = probablyCrossOrigin(url);
  try {
    return instantiateModuleWorkerAttempt(url, tryTrampolineFirst);
  } catch {
    return instantiateModuleWorkerAttempt(url, !tryTrampolineFirst);
  }
}
async function instantiateModuleWorkerAttempt(workerEntryFileURL, crossOriginTrampoline) {
  return new Promise(async (resolve, reject) => {
    try {
      if (!workerEntryFileURL) {
        reject(new Error("Could not get worker entry file URL."));
      }
      let url = workerEntryFileURL;
      if (crossOriginTrampoline) {
        const importSrc = `import ${JSON.stringify(
          workerEntryFileURL.toString()
        )};`;
        const blob = new Blob([importSrc], {
          type: "text/javascript"
        });
        url = new URL(URL.createObjectURL(blob));
      }
      const worker = await constructWorker(url, {
        type: "module"
      });
      worker.unref?.();
      const onError = (e) => {
        reject(e);
      };
      const onFirstMessage = (messageData) => {
        if (messageData === "comlink-exposed") {
          resolve(wrapWithTerminateAndRefs(worker));
        } else {
          reject(
            new Error(`wrong module instantiation message ${messageData}`)
          );
        }
      };
      if (worker.nodeWorker) {
        worker.nodeWorker.once("message", onFirstMessage);
      } else {
        worker.addEventListener("error", onError, {
          once: true
        });
        worker.addEventListener("message", (e) => onFirstMessage(e.data), {
          once: true
        });
      }
    } catch (e) {
      reject(e);
    }
  });
}
async function instantiateModuleWorkerDirectlyForBrowser() {
  return new Promise(async (resolve, reject) => {
    try {
      const worker = instantiateSearchWorkerURLNewURLImportMetaURL();
      const onError = (e) => {
        reject(e);
      };
      const onFirstMessage = (messageData) => {
        if (messageData === "comlink-exposed") {
          resolve(wrapWithTerminateAndRefs(worker));
        } else {
          reject(
            new Error(`wrong module instantiation message ${messageData}`)
          );
        }
      };
      worker.addEventListener("error", onError, {
        once: true
      });
      worker.addEventListener("message", (e) => onFirstMessage(e.data), {
        once: true
      });
    } catch (e) {
      reject(e);
    }
  });
}
function wrapWithTerminateAndRefs(worker) {
  const insideAPI = wrap(worker);
  const terminate = worker.terminate.bind(worker);
  const nodeWorker2 = worker.nodeWorker;
  const ref = nodeWorker2?.ref?.bind(nodeWorker2) ?? (() => {
  });
  const unref = nodeWorker2?.unref?.bind(nodeWorker2) ?? (() => {
  });
  return { insideAPI, outsideAPI: { terminate, ref, unref } };
}
var allInsideOutsideAPIPromises = [];
async function instantiateWorker() {
  const insideOutsideAPIPromise = instantiateWorkerImplementation();
  allInsideOutsideAPIPromises.push(insideOutsideAPIPromise);
  const { insideAPI } = await insideOutsideAPIPromise;
  insideAPI.setDebugMeasurePerf(searchOutsideDebugGlobals.logPerf);
  insideAPI.setScramblePrefetchLevel(
    searchOutsideDebugGlobals.scramblePrefetchLevel
  );
  return insideOutsideAPIPromise;
}
async function instantiateWorkerImplementation() {
  if (globalThis.location?.protocol === "file:") {
    console.warn(
      "This current web page is loaded from the local filesystem (a URL that starts with `file://`). In this situation, `cubing.js` may be unable to generate scrambles or perform searches in some browsers. See: https://js.cubing.net/cubing/scramble/#file-server-required"
    );
  }
  function failed(methodDescription) {
    return `Module worker instantiation${methodDescription ? ` ${methodDescription}` : ""} failed`;
  }
  const importMetaResolveStrategy = [
    async () => instantiateModuleWorker(searchWorkerURLImportMetaResolve()),
    "using `import.meta.resolve(\u2026)",
    null
  ];
  const esbuildWorkaroundStrategy = [
    async () => instantiateModuleWorker(await searchWorkerURLEsbuildWorkaround()),
    "using the `esbuild` workaround",
    // TODO: we will hopefully discontinue the `esbuild` workaround at some
    // point, but `esbuild` has been stuck for 3 years on this issue. Because
    // `esbuild` and Vite (which uses `esbuild`) are now dominating the
    // ecosystem, this just causes a warning for a lot of devs/users that they
    // can't do anything about. As frustrating as the situation is, the
    // workaround is semantically fine (even if it's convoluted) and is
    // preserved by `esbuild`-based flows in practice. So we suppress the
    // warning in the medium-term but maintain long-term hope that we can
    // remove it (and the other fallbacks as well).
    null
  ];
  const newURLStrategy = [
    async () => instantiateModuleWorker(searchWorkerURLNewURLImportMetaURL()),
    "using `new URL(\u2026, import.meta.url)`",
    "will"
  ];
  const inlineNewURLStrategy = [
    instantiateModuleWorkerDirectlyForBrowser,
    "using inline `new URL(\u2026, import.meta.url)`",
    "may"
  ];
  const fallbackOrder = searchOutsideDebugGlobals.prioritizeEsbuildWorkaroundForWorkerInstantiation ? [
    esbuildWorkaroundStrategy,
    importMetaResolveStrategy,
    newURLStrategy,
    inlineNewURLStrategy
  ] : [
    importMetaResolveStrategy,
    esbuildWorkaroundStrategy,
    newURLStrategy,
    inlineNewURLStrategy
  ];
  for (const [fn, description, warnOnSuccess] of fallbackOrder) {
    try {
      const worker = await fn();
      if (warnOnSuccess) {
        if (searchOutsideDebugGlobals.showWorkerInstantiationWarnings) {
          console.warn(
            `Module worker instantiation required ${description}. \`cubing.js\` ${warnOnSuccess} not support this fallback in the future.`
          );
        }
      }
      return worker;
    } catch {
    }
  }
  throw new Error(`${failed()}. There are no more fallbacks available.`);
}

// src/cubing/search/outside.ts
var cachedWorkerInstance;
function getCachedWorkerInstance() {
  return cachedWorkerInstance ??= instantiateWorker();
}
var leases = /* @__PURE__ */ new WeakMap();
async function leaseRef(api, promiseFn) {
  if (!leases.has(api)) {
    leases.set(api, /* @__PURE__ */ new Set());
  }
  const promise = promiseFn(api);
  const leasesForWorker = leases.get(api);
  leasesForWorker.add(promise);
  api.outsideAPI?.ref?.();
  try {
    return await promise;
  } finally {
    leasesForWorker.delete(promise);
    if (leasesForWorker.size === 0) {
      api.outsideAPI?.unref();
    }
  }
}
async function leaseCachedWorkerInstanceRef(promiseFn) {
  return leaseRef(await getCachedWorkerInstance(), promiseFn);
}
async function mapToAllWorkers(f) {
  await Promise.all(
    allInsideOutsideAPIPromises.map(async (worker) => {
      await leaseRef(await worker, async (worker2) => f(worker2));
    })
  );
}
async function randomScrambleForEvent(eventID) {
  const worker = searchOutsideDebugGlobals.forceNewWorkerForEveryScramble ? await instantiateWorker() : await getCachedWorkerInstance();
  const scrambleString = await leaseRef(
    worker,
    (worker2) => worker2.insideAPI.randomScrambleStringForEvent(eventID)
  );
  return Alg.fromString(scrambleString);
}
async function deriveScrambleForEvent(derivationSeedHex, derivationSaltHierarchy, eventID) {
  if (!searchOutsideDebugGlobals.allowDerivedScrambles) {
    throw new Error("Derived scrambles are not allowed.");
  }
  const worker = searchOutsideDebugGlobals.forceNewWorkerForEveryScramble ? await instantiateWorker() : await getCachedWorkerInstance();
  const scrambleString = await leaseRef(
    worker,
    (worker2) => worker2.insideAPI.deriveScrambleStringForEvent(
      derivationSeedHex,
      derivationSaltHierarchy,
      eventID
    )
  );
  return Alg.fromString(scrambleString);
}
async function experimentalSolve3x3x3IgnoringCenters(pattern) {
  return Alg.fromString(
    await leaseCachedWorkerInstanceRef(
      (cwi) => cwi.insideAPI.solve333ToString(pattern.patternData)
    )
  );
}
async function experimentalSolve2x2x2(pattern) {
  return Alg.fromString(
    await leaseCachedWorkerInstanceRef(
      (cwi) => cwi.insideAPI.solve222ToString(pattern.patternData)
    )
  );
}
async function solveSkewb(pattern) {
  return Alg.fromString(
    await leaseCachedWorkerInstanceRef(
      (cwi) => cwi.insideAPI.solveSkewbToString(pattern.patternData)
    )
  );
}
async function solvePyraminx(pattern) {
  return Alg.fromString(
    await leaseCachedWorkerInstanceRef(
      (cwi) => cwi.insideAPI.solvePyraminxToString(pattern.patternData)
    )
  );
}
async function solveMegaminx(pattern) {
  return Alg.fromString(
    await leaseCachedWorkerInstanceRef(
      (cwi) => cwi.insideAPI.solveMegaminxToString(pattern.patternData)
    )
  );
}
async function solveTwips(kpuzzle, pattern, options) {
  const { targetPattern, ...otherOptions } = options ?? {};
  const apiOptions = otherOptions;
  if (targetPattern) {
    apiOptions.targetPattern = targetPattern.patternData;
  }
  const { ...def } = kpuzzle.definition;
  delete def.experimentalIsPatternSolved;
  const dedicatedWorker = await instantiateWorker();
  try {
    return Alg.fromString(
      // TODO: unnecessary because we terminate the worker?
      await leaseRef(
        dedicatedWorker,
        (worker) => worker.insideAPI.solveTwipsToString(
          def,
          pattern.patternData,
          apiOptions
        )
      )
    );
  } finally {
    console.log("Search ended, terminating dedicated `twips` worker.");
    dedicatedWorker.outsideAPI.terminate();
  }
}
var searchOutsideDebugGlobals = {
  logPerf: true,
  scramblePrefetchLevel: "auto",
  forceNewWorkerForEveryScramble: false,
  showWorkerInstantiationWarnings: true,
  prioritizeEsbuildWorkaroundForWorkerInstantiation: false,
  allowDerivedScrambles: false
};
function setSearchDebug(options) {
  const { logPerf, scramblePrefetchLevel } = options;
  if (typeof logPerf !== "undefined") {
    searchOutsideDebugGlobals.logPerf = logPerf;
    void mapToAllWorkers(
      (worker) => worker.insideAPI.setDebugMeasurePerf(logPerf)
    );
  }
  if (typeof scramblePrefetchLevel !== "undefined") {
    searchOutsideDebugGlobals.scramblePrefetchLevel = scramblePrefetchLevel;
    void mapToAllWorkers(
      (worker) => worker.insideAPI.setScramblePrefetchLevel(
        scramblePrefetchLevel
      )
    );
  }
  for (const booleanField of [
    "forceNewWorkerForEveryScramble",
    "showWorkerInstantiationWarnings",
    "prioritizeEsbuildWorkaroundForWorkerInstantiation",
    "allowDerivedScrambles"
  ]) {
    if (booleanField in options) {
      searchOutsideDebugGlobals[booleanField] = options[booleanField] ?? searchOutsideDebugGlobals[booleanField];
    }
  }
}

export {
  randomScrambleForEvent,
  deriveScrambleForEvent,
  experimentalSolve3x3x3IgnoringCenters,
  experimentalSolve2x2x2,
  solveSkewb,
  solvePyraminx,
  solveMegaminx,
  solveTwips,
  setSearchDebug
};
//# sourceMappingURL=chunk-LIVDX4MD.js.map
