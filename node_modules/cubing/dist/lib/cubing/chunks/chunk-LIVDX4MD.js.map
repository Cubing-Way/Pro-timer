{
  "version": 3,
  "sources": ["../../../../src/cubing/vendor/apache/comlink-everywhere/outside/index.ts", "../../../../src/cubing/search/worker-workarounds/index.ts", "../../../../src/cubing/search/instantiator.ts", "../../../../src/cubing/search/outside.ts"],
  "sourcesContent": ["import nodeEndpoint from \"../node-adapter\";\n\nexport { wrap } from \"comlink\";\n\nconst useNodeWorkarounds =\n  typeof globalThis.Worker === \"undefined\" &&\n  typeof (globalThis as any).WorkerNavigator === \"undefined\";\n\nasync function nodeWorker(\n  source: string | URL,\n  options?: { eval?: boolean },\n): Promise<Worker> {\n  const { Worker: NodeWorker } = globalThis.process.getBuiltinModule(\n    \"node:worker_threads\",\n  );\n  const worker = new NodeWorker(source, options);\n  // worker.unref();\n  return nodeEndpoint(worker);\n}\n\nexport async function constructWorker(\n  source: string | URL,\n  options?: { type?: WorkerType },\n): Promise<Worker> {\n  let worker: Worker;\n  if (useNodeWorkarounds) {\n    return nodeWorker(source);\n  } else {\n    worker = new globalThis.Worker(source, {\n      type: options ? options.type : undefined, // TODO: Is it safe to use `options?.type`?\n    });\n  }\n  return worker;\n}\n", "import { exposeAPI } from \"./worker-guard\";\n\nexport function searchWorkerURLImportMetaResolve(): string {\n  // Note:\n  // - We have to hardcode the expected path of the entry file in the ESM build, due to lack of `esbuild` support: https://github.com/evanw/esbuild/issues/2866\n  //   - This URL is based on the assumption that the code from this file ends up in a shared chunk in the `esm` build. This is not guaranteed by `esbuild`, but it consistently happens for our codebase.\n  // - We inline the value (instead of using a constant), to maximize compatibility for hardcoded syntax detection in bundlers.\n  return import.meta.resolve(\"./search-worker-entry.js\");\n}\n\nexport function searchWorkerURLNewURLImportMetaURL(): URL {\n  // Note:\n  // - We have to hardcode the expected path of the entry file in the ESM build, due to lack of `esbuild` support: https://github.com/evanw/esbuild/issues/795\n  //   - This URL is based on the assumption that the code from this file ends up in a shared chunk in the `esm` build. This is not guaranteed by `esbuild`, but it consistently happens for our codebase.\n  // - We inline the value (instead of using a constant), to maximize compatibility for hardcoded syntax detection in bundlers.\n  return new URL(\"./search-worker-entry.js\", import.meta.url);\n}\n\n// Workaround for `esbuild`: https://github.com/evanw/esbuild/issues/312#issuecomment-1092195778\nexport async function searchWorkerURLEsbuildWorkaround(): Promise<string> {\n  exposeAPI.expose = false;\n  return (await import(\"./search-worker-entry.js\")).WORKER_ENTRY_FILE_URL;\n}\n\nexport function instantiateSearchWorkerURLNewURLImportMetaURL(): Worker {\n  return new Worker(new URL(\"./search-worker-entry.js\", import.meta.url), {\n    type: \"module\",\n  });\n}\n", "import type { NodeWorker } from \"../vendor/apache/comlink-everywhere/node-adapter\";\nimport {\n  constructWorker,\n  wrap,\n} from \"../vendor/apache/comlink-everywhere/outside\";\nimport type { WorkerInsideAPI } from \"./inside/api\";\nimport { searchOutsideDebugGlobals } from \"./outside\";\nimport {\n  instantiateSearchWorkerURLNewURLImportMetaURL,\n  searchWorkerURLEsbuildWorkaround,\n  searchWorkerURLImportMetaResolve,\n  searchWorkerURLNewURLImportMetaURL,\n} from \"./worker-workarounds\";\n\nexport interface WorkerOutsideAPI {\n  terminate: () => void; // `node` can return a `Promise` with an exit code, but we match the web worker API.\n  ref: () => void;\n  unref: () => void;\n}\n\nexport interface InsideOutsideAPI {\n  insideAPI: WorkerInsideAPI;\n  outsideAPI: WorkerOutsideAPI;\n}\n\nfunction probablyCrossOrigin(workerEntryFileURL: URL): boolean {\n  try {\n    const scriptOrigin = globalThis.location?.origin;\n    const workerOrigin = workerEntryFileURL.origin;\n    return !!scriptOrigin && !!workerOrigin && scriptOrigin !== workerOrigin;\n  } catch {\n    return false;\n  }\n}\n\nasync function instantiateModuleWorker(\n  workerEntryFileURL: string | URL,\n): Promise<InsideOutsideAPI> {\n  // We need the `import.meta.url` base for `bun`.\n  const url = new URL(workerEntryFileURL, import.meta.url);\n  const tryTrampolineFirst = probablyCrossOrigin(url);\n  try {\n    return instantiateModuleWorkerAttempt(url, tryTrampolineFirst);\n  } catch {\n    return instantiateModuleWorkerAttempt(url, !tryTrampolineFirst);\n  }\n}\n\ninterface BunWorker extends Worker {\n  unref?: () => void;\n}\n\nasync function instantiateModuleWorkerAttempt(\n  workerEntryFileURL: URL,\n  crossOriginTrampoline: boolean,\n): Promise<InsideOutsideAPI> {\n  // biome-ignore lint/suspicious/noAsyncPromiseExecutor: TODO\n  return new Promise<InsideOutsideAPI>(async (resolve, reject) => {\n    try {\n      if (!workerEntryFileURL) {\n        reject(new Error(\"Could not get worker entry file URL.\"));\n      }\n      let url: URL = workerEntryFileURL;\n      if (crossOriginTrampoline) {\n        // Standard browser-like environment.\n        const importSrc = `import ${JSON.stringify(\n          workerEntryFileURL.toString(),\n        )};`;\n        const blob = new Blob([importSrc], {\n          type: \"text/javascript\",\n        });\n        url = new URL(URL.createObjectURL(blob));\n      }\n\n      const worker = (await constructWorker(url, {\n        type: \"module\",\n      })) as Worker & {\n        nodeWorker?: NodeWorker;\n      } & BunWorker;\n\n      worker.unref?.(); // Unref in `bun`.\n\n      const onError = (e: ErrorEvent) => {\n        reject(e);\n      };\n\n      // TODO: Remove this once we can remove the workarounds for lack of `import.meta.resolve(\u2026)` support.\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          resolve(wrapWithTerminateAndRefs(worker));\n        } else {\n          reject(\n            new Error(`wrong module instantiation message ${messageData}`),\n          );\n        }\n      };\n\n      if (worker.nodeWorker) {\n        // We have to use `once` so the `unref()` from `comlink-everywhere` allows the process to quit as expected.\n        worker.nodeWorker.once(\"message\", onFirstMessage);\n      } else {\n        worker.addEventListener(\"error\", onError, {\n          once: true,\n        });\n        worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n          once: true,\n        });\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// Maybe some day if we work really hard, this code path can work:\n// - in `node` (https://github.com/nodejs/node/issues/43583#issuecomment-1540025755)\n// - for CDNs (https://github.com/tc39/proposal-module-expressions or https://github.com/whatwg/html/issues/6911)\nexport async function instantiateModuleWorkerDirectlyForBrowser(): Promise<InsideOutsideAPI> {\n  // biome-ignore lint/suspicious/noAsyncPromiseExecutor: TODO\n  return new Promise<InsideOutsideAPI>(async (resolve, reject) => {\n    try {\n      const worker = instantiateSearchWorkerURLNewURLImportMetaURL();\n\n      const onError = (e: ErrorEvent) => {\n        reject(e);\n      };\n\n      // TODO: Remove this once we can remove the workarounds for lack of `import.meta.resolve(\u2026)` support.\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          resolve(wrapWithTerminateAndRefs(worker));\n        } else {\n          reject(\n            new Error(`wrong module instantiation message ${messageData}`),\n          );\n        }\n      };\n\n      worker.addEventListener(\"error\", onError, {\n        once: true,\n      });\n      worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n        once: true,\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nfunction wrapWithTerminateAndRefs(worker: Worker): InsideOutsideAPI {\n  const insideAPI = wrap<WorkerInsideAPI>(worker);\n  const terminate = worker.terminate.bind(worker);\n  const nodeWorker = (worker as Worker & { nodeWorker?: NodeWorker })\n    .nodeWorker;\n  const ref = nodeWorker?.ref?.bind(nodeWorker) ?? (() => {});\n  const unref = nodeWorker?.unref?.bind(nodeWorker) ?? (() => {});\n  return { insideAPI, outsideAPI: { terminate, ref, unref } };\n}\n\nexport const allInsideOutsideAPIPromises: Promise<InsideOutsideAPI>[] = [];\n\nexport async function instantiateWorker(): Promise<InsideOutsideAPI> {\n  const insideOutsideAPIPromise = instantiateWorkerImplementation();\n  allInsideOutsideAPIPromises.push(insideOutsideAPIPromise);\n  const { insideAPI } = await insideOutsideAPIPromise;\n  insideAPI.setDebugMeasurePerf(searchOutsideDebugGlobals.logPerf);\n  insideAPI.setScramblePrefetchLevel(\n    searchOutsideDebugGlobals.scramblePrefetchLevel,\n  );\n  return insideOutsideAPIPromise;\n}\n\ntype FallbackStrategyInfo = [\n  fn: () => Promise<InsideOutsideAPI>,\n  description: string,\n  warnOnSuccess: null | string,\n];\n\nasync function instantiateWorkerImplementation(): Promise<InsideOutsideAPI> {\n  if (globalThis.location?.protocol === \"file:\") {\n    console.warn(\n      \"This current web page is loaded from the local filesystem (a URL that starts with `file://`). In this situation, `cubing.js` may be unable to generate scrambles or perform searches in some browsers. See: https://js.cubing.net/cubing/scramble/#file-server-required\",\n    );\n  }\n\n  function failed(methodDescription?: string) {\n    return `Module worker instantiation${\n      methodDescription ? ` ${methodDescription}` : \"\"\n    } failed`;\n  }\n\n  const importMetaResolveStrategy: FallbackStrategyInfo = [\n    async () => instantiateModuleWorker(searchWorkerURLImportMetaResolve()),\n    \"using `import.meta.resolve(\u2026)\",\n    null,\n  ];\n  const esbuildWorkaroundStrategy: FallbackStrategyInfo = [\n    async () =>\n      instantiateModuleWorker(await searchWorkerURLEsbuildWorkaround()),\n    \"using the `esbuild` workaround\",\n    // TODO: we will hopefully discontinue the `esbuild` workaround at some\n    // point, but `esbuild` has been stuck for 3 years on this issue. Because\n    // `esbuild` and Vite (which uses `esbuild`) are now dominating the\n    // ecosystem, this just causes a warning for a lot of devs/users that they\n    // can't do anything about. As frustrating as the situation is, the\n    // workaround is semantically fine (even if it's convoluted) and is\n    // preserved by `esbuild`-based flows in practice. So we suppress the\n    // warning in the medium-term but maintain long-term hope that we can\n    // remove it (and the other fallbacks as well).\n    null,\n  ];\n  const newURLStrategy: FallbackStrategyInfo = [\n    async () => instantiateModuleWorker(searchWorkerURLNewURLImportMetaURL()),\n    \"using `new URL(\u2026, import.meta.url)`\",\n    \"will\",\n  ];\n  const inlineNewURLStrategy: FallbackStrategyInfo = [\n    instantiateModuleWorkerDirectlyForBrowser,\n    \"using inline `new URL(\u2026, import.meta.url)`\",\n    \"may\",\n  ];\n\n  const fallbackOrder: FallbackStrategyInfo[] =\n    searchOutsideDebugGlobals.prioritizeEsbuildWorkaroundForWorkerInstantiation\n      ? [\n          esbuildWorkaroundStrategy,\n          importMetaResolveStrategy,\n          newURLStrategy,\n          inlineNewURLStrategy,\n        ]\n      : [\n          importMetaResolveStrategy,\n          esbuildWorkaroundStrategy,\n          newURLStrategy,\n          inlineNewURLStrategy,\n        ];\n\n  for (const [fn, description, warnOnSuccess] of fallbackOrder) {\n    try {\n      const worker = await fn();\n      if (warnOnSuccess) {\n        if (searchOutsideDebugGlobals.showWorkerInstantiationWarnings) {\n          console.warn(\n            `Module worker instantiation required ${description}. \\`cubing.js\\` ${warnOnSuccess} not support this fallback in the future.`,\n          );\n        }\n      }\n      return worker;\n    } catch {\n      // if (searchOutsideDebugGlobals.showWorkerInstantiationWarnings) {\n      //   console.warn(`${failed(description)}, falling back.`);\n      // }\n    }\n  }\n\n  throw new Error(`${failed()}. There are no more fallbacks available.`);\n}\n", "import { Alg } from \"../alg\";\nimport type { KPuzzle } from \"../kpuzzle\";\n// import { preInitialize222 } from \"../implementations/2x2x2\";\nimport type { KPattern } from \"../kpuzzle/KPattern\";\nimport type { PrefetchLevel } from \"./inside/api\";\nimport type { TwipsOptions } from \"./inside/solve/twips\";\nimport {\n  allInsideOutsideAPIPromises,\n  type InsideOutsideAPI,\n  instantiateWorker,\n} from \"./instantiator\";\n\nlet cachedWorkerInstance: Promise<InsideOutsideAPI> | undefined;\nfunction getCachedWorkerInstance(): Promise<InsideOutsideAPI> {\n  return (cachedWorkerInstance ??= instantiateWorker());\n}\n\n/**\n * `node` has the unfortunate semantics that:\n *\n * - Every message refs a worker.\n * - The process hangs if any reffed worker still exists.\n *\n * And we need workers with pending scrambles to be reffed to avoid\n * https://github.com/cubing/cubing.js/issues/358\n *\n * So we have to carefully track everything that can result in message\n * exchanges, and unref once the line has gone quiet (until reffed again).\n *\n * We don't technically need to ref here (just unref), but we do it because:\n *\n * - it's not hard to do,\n * - it makes the implementation more clear,\n * - it can guard against subtle race conditions to do it here synchronously.\n *\n */\n// TODO: this should be pushed to the comlink layer.\nconst leases: WeakMap<InsideOutsideAPI, Set<Promise<any>>> = new WeakMap();\nasync function leaseRef<T>(\n  api: InsideOutsideAPI,\n  promiseFn: (api: InsideOutsideAPI) => Promise<T>,\n) {\n  if (!leases.has(api)) {\n    leases.set(api, new Set());\n  }\n  const promise = promiseFn(api);\n  const leasesForWorker = leases.get(api)!;\n  leasesForWorker.add(promise);\n  api.outsideAPI?.ref?.();\n  try {\n    // Note: the `await` is critical here.\n    return await promise;\n  } finally {\n    leasesForWorker.delete(promise);\n    if (leasesForWorker.size === 0) {\n      api.outsideAPI?.unref();\n    }\n  }\n}\n\nasync function leaseCachedWorkerInstanceRef<T>(\n  promiseFn: (cwi: InsideOutsideAPI) => Promise<T>,\n): Promise<T> {\n  // TODO: typing\n  return leaseRef((await getCachedWorkerInstance()) as any, promiseFn);\n}\n\nexport async function mapToAllWorkers(\n  f: (worker: InsideOutsideAPI) => void,\n): Promise<void> {\n  await Promise.all(\n    allInsideOutsideAPIPromises.map(async (worker) => {\n      await leaseRef(await worker, async (worker) => f(worker));\n    }),\n  );\n}\n\n// Pre-initialize the scrambler for the given event. (Otherwise, an event is\n// initialized the first time you ask for a scramble for that event.)\n//\n// Some typical numbers for a fast computer:\n// - 3x3x3 initialization: 200ms\n// - Each 3x3x3 scramble: 50ms\n// - 4x4x4 initialization: 2500ms\n// - Each 4x4x4 scramble: 300ms to 800ms\n//\n// It is safe to immediately call for a scramble\n// any time after starting pre-initialization, or to call for them without\n// pre-initializing. Pre-initializing essentially gives the scramble worker a\n// head start in case a scramble doesn't get requested immediately.\n//\n// Note that events cannot be pre-initialized in parallel. Attempting to\n// pre-initialize multiple events will initialize them consecutively. Scrambles\n// for a given event cannot be computed while another event is being initialized.\nexport function _preInitializationHintForEvent(\n  eventID: string,\n  // callback?: () => void\n): void {\n  switch (eventID) {\n    case \"333oh\":\n      _preInitializationHintForEvent(\"333\");\n      return;\n  }\n  void (async () => {\n    await (await getCachedWorkerInstance()).insideAPI.initialize(eventID);\n  })();\n}\n\nexport async function randomScrambleForEvent(eventID: string): Promise<Alg> {\n  const worker = searchOutsideDebugGlobals.forceNewWorkerForEveryScramble\n    ? await instantiateWorker()\n    : await getCachedWorkerInstance();\n  const scrambleString = await leaseRef(worker, (worker) =>\n    worker.insideAPI.randomScrambleStringForEvent(eventID),\n  );\n  return Alg.fromString(scrambleString);\n}\n\nexport async function deriveScrambleForEvent(\n  derivationSeedHex: string,\n  derivationSaltHierarchy: string[],\n  eventID: string,\n): Promise<Alg> {\n  if (!searchOutsideDebugGlobals.allowDerivedScrambles) {\n    throw new Error(\"Derived scrambles are not allowed.\");\n  }\n  const worker = searchOutsideDebugGlobals.forceNewWorkerForEveryScramble\n    ? await instantiateWorker()\n    : await getCachedWorkerInstance();\n  const scrambleString = await leaseRef(worker, (worker) =>\n    worker.insideAPI.deriveScrambleStringForEvent(\n      derivationSeedHex,\n      derivationSaltHierarchy,\n      eventID,\n    ),\n  );\n  return Alg.fromString(scrambleString);\n}\n\nexport async function experimentalSolve3x3x3IgnoringCenters(\n  pattern: KPattern,\n): Promise<Alg> {\n  return Alg.fromString(\n    await leaseCachedWorkerInstanceRef((cwi) =>\n      cwi.insideAPI.solve333ToString(pattern.patternData),\n    ),\n  );\n}\n\nexport async function experimentalSolve2x2x2(pattern: KPattern): Promise<Alg> {\n  return Alg.fromString(\n    await leaseCachedWorkerInstanceRef((cwi) =>\n      cwi.insideAPI.solve222ToString(pattern.patternData),\n    ),\n  );\n}\n\nexport async function solveSkewb(pattern: KPattern): Promise<Alg> {\n  return Alg.fromString(\n    await leaseCachedWorkerInstanceRef((cwi) =>\n      cwi.insideAPI.solveSkewbToString(pattern.patternData),\n    ),\n  );\n}\n\nexport async function solvePyraminx(pattern: KPattern): Promise<Alg> {\n  return Alg.fromString(\n    await leaseCachedWorkerInstanceRef((cwi) =>\n      cwi.insideAPI.solvePyraminxToString(pattern.patternData),\n    ),\n  );\n}\n\nexport async function solveMegaminx(pattern: KPattern): Promise<Alg> {\n  return Alg.fromString(\n    await leaseCachedWorkerInstanceRef((cwi) =>\n      cwi.insideAPI.solveMegaminxToString(pattern.patternData),\n    ),\n  );\n}\n\nexport interface SolveTwipsOptions {\n  generatorMoves?: string[];\n  targetPattern?: KPattern;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nexport async function solveTwips(\n  kpuzzle: KPuzzle,\n  pattern: KPattern,\n  options?: SolveTwipsOptions,\n): Promise<Alg> {\n  const { targetPattern, ...otherOptions } = options ?? {};\n  const apiOptions: TwipsOptions = otherOptions;\n  if (targetPattern) {\n    apiOptions.targetPattern = targetPattern.patternData;\n  }\n  const { ...def } = kpuzzle.definition;\n  delete def.experimentalIsPatternSolved;\n  // delete def.derivedMoves;\n  const dedicatedWorker = await instantiateWorker();\n  try {\n    return Alg.fromString(\n      // TODO: unnecessary because we terminate the worker?\n      await leaseRef(dedicatedWorker, (worker) =>\n        worker.insideAPI.solveTwipsToString(\n          def,\n          pattern.patternData,\n          apiOptions,\n        ),\n      ),\n    );\n  } finally {\n    console.log(\"Search ended, terminating dedicated `twips` worker.\");\n    // TODO: support re-using the same worker for multiple searches..\n    dedicatedWorker.outsideAPI.terminate();\n  }\n}\n\ninterface SearchOutsideDebugGlobals {\n  logPerf: boolean;\n  scramblePrefetchLevel: `${PrefetchLevel}`;\n  forceNewWorkerForEveryScramble: boolean;\n  showWorkerInstantiationWarnings: boolean;\n  // This can prevent a request to `search-worker-entry.js` when it doesn't exist, if the library semantics have been mangled by `esbuild`.\n  prioritizeEsbuildWorkaroundForWorkerInstantiation: boolean;\n  allowDerivedScrambles: boolean;\n}\n\nexport const searchOutsideDebugGlobals: SearchOutsideDebugGlobals = {\n  logPerf: true,\n  scramblePrefetchLevel: \"auto\",\n  forceNewWorkerForEveryScramble: false,\n  showWorkerInstantiationWarnings: true,\n  prioritizeEsbuildWorkaroundForWorkerInstantiation: false,\n  allowDerivedScrambles: false,\n};\n\nexport function setSearchDebug(\n  options: Partial<SearchOutsideDebugGlobals>,\n): void {\n  const { logPerf, scramblePrefetchLevel } = options;\n  if (typeof logPerf !== \"undefined\") {\n    searchOutsideDebugGlobals.logPerf = logPerf;\n    void mapToAllWorkers((worker) =>\n      worker.insideAPI.setDebugMeasurePerf(logPerf),\n    );\n  }\n  if (typeof scramblePrefetchLevel !== \"undefined\") {\n    searchOutsideDebugGlobals.scramblePrefetchLevel = scramblePrefetchLevel;\n    void mapToAllWorkers((worker) =>\n      worker.insideAPI.setScramblePrefetchLevel(\n        scramblePrefetchLevel as PrefetchLevel,\n      ),\n    );\n  }\n  for (const booleanField of [\n    \"forceNewWorkerForEveryScramble\",\n    \"showWorkerInstantiationWarnings\",\n    \"prioritizeEsbuildWorkaroundForWorkerInstantiation\",\n    \"allowDerivedScrambles\",\n  ] as const) {\n    if (booleanField in options) {\n      searchOutsideDebugGlobals[booleanField] =\n        options[booleanField] ?? searchOutsideDebugGlobals[booleanField];\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["nodeWorker", "worker", "worker"]
}
