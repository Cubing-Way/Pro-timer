import { runParser } from "@optique/core/facade";
import path from "node:path";
import process from "node:process";

//#region src/run.ts
/**
* Runs a command-line parser with automatic process integration.
*
* This function provides a convenient high-level interface for parsing
* command-line arguments in Node.js, Bun, and Deno environments. It
* automatically handles `process.argv`, `process.exit()`, and terminal
* output formatting, eliminating the need to manually pass these values
* as the lower-level `run()` function (from `@optique/core/facade`) requires.
*
* The function will automatically:
*
* - Extract arguments from `process.argv`
* - Detect terminal capabilities for colors and width
* - Exit the process with appropriate codes on help or error
* - Format output according to terminal capabilities
*
* @template T The parser type being executed.
* @param parser The command-line parser to execute.
* @param options Configuration options for customizing behavior.
*                See {@link RunOptions} for available settings.
* @returns The parsed result if successful. On help display or parse errors,
*          the function will call `process.exit()` and not return.
*
* @example
* ```typescript
* import { object, option, run } from "@optique/run";
* import { string, integer } from "@optique/core/valueparser";
*
* const parser = object({
*   name: option("-n", "--name", string()),
*   port: option("-p", "--port", integer()),
* });
*
* // Automatically uses process.argv, handles errors/help, exits on completion
* const config = run(parser);
* console.log(`Starting server ${config.name} on port ${config.port}`);
* ```
*
* @example
* ```typescript
* // With custom options
* const result = run(parser, {
*   programName: "myapp",
*   help: "both",           // Enable both --help option and help command
*   completion: "both",     // Enable both completion command and --completion option
*   colors: true,           // Force colored output
*   errorExitCode: 2,       // Exit with code 2 on errors
* });
* ```
*
* @example
* ```typescript
* // Shell completion usage
* const result = run(parser, {
*   completion: "both",
* });
*
* // Users can then:
* // myapp completion bash > ~/.bash_completion.d/myapp  # Generate script
* // source ~/.bash_completion.d/myapp                   # Enable completion
* // myapp --format=<TAB>                                # Use completion
* ```
*/
function run(parser, options = {}) {
	const { programName = path.basename(process.argv[1] || "cli"), args = process.argv.slice(2), colors = process.stdout.isTTY, maxWidth = process.stdout.columns, showDefault, help, version, completion, aboveError = "usage", errorExitCode = 1, brief, description, footer } = options;
	const helpConfig = help ? {
		mode: help,
		onShow: () => process.exit(0)
	} : void 0;
	const versionConfig = version ? {
		mode: typeof version === "string" ? "option" : version.mode ?? "option",
		value: typeof version === "string" ? version : version.value,
		onShow: () => process.exit(0)
	} : void 0;
	const completionConfig = completion ? {
		mode: typeof completion === "string" ? completion : completion.mode ?? "both",
		shells: typeof completion === "string" ? void 0 : completion.shells,
		name: typeof completion === "string" ? "both" : completion.name ?? "both",
		onShow: () => process.exit(0)
	} : void 0;
	return runParser(parser, programName, args, {
		stderr(line) {
			process.stderr.write(`${line}\n`);
		},
		stdout(line) {
			process.stdout.write(`${line}\n`);
		},
		colors,
		maxWidth,
		showDefault,
		help: helpConfig,
		version: versionConfig,
		completion: completionConfig,
		aboveError,
		brief,
		description,
		footer,
		onError() {
			return process.exit(errorExitCode);
		}
	});
}

//#endregion
export { run };