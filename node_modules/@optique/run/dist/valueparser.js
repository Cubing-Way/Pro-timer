import { dirname, extname } from "node:path";
import { message, text } from "@optique/core/message";
import { ensureNonEmptyString } from "@optique/core/nonempty";
import { existsSync, statSync } from "node:fs";

//#region src/valueparser.ts
/**
* Creates a ValueParser for file system paths with validation options.
*
* This parser provides filesystem validation and type checking for command-line
* path arguments. It can validate existence, file vs directory types, parent
* directory existence for new files, and file extensions.
*
* @param options Configuration options for path validation.
* @returns A ValueParser that validates and returns string paths.
*
* @example
* ```typescript
* import { path } from "@optique/run";
* import { argument, object } from "@optique/core/parser";
*
* // Basic path parser (any path, no validation)
* const configFile = argument(path());
*
* // File must exist
* const inputFile = argument(path({ mustExist: true }));
*
* // Directory must exist
* const outputDir = argument(path({ mustExist: true, type: "directory" }));
*
* // File can be created (parent directory must exist)
* const logFile = argument(path({ type: "file", allowCreate: true }));
*
* // Config files with specific extensions
* const config = argument(path({
*   mustExist: true,
*   type: "file",
*   extensions: [".json", ".yaml", ".yml"]
* }));
* ```
*/
function path(options = {}) {
	const { metavar = "PATH", type = "either", allowCreate = false, extensions } = options;
	ensureNonEmptyString(metavar);
	const mustExist = "mustExist" in options ? options.mustExist : false;
	const mustNotExist = "mustNotExist" in options ? options.mustNotExist : false;
	return {
		metavar,
		parse(input) {
			if (extensions && extensions.length > 0) {
				const ext = extname(input);
				if (!extensions.includes(ext)) {
					const actualExt = ext || "no extension";
					return {
						success: false,
						error: options.errors?.invalidExtension ? typeof options.errors.invalidExtension === "function" ? options.errors.invalidExtension(input, extensions, actualExt) : options.errors.invalidExtension : message`Expected file with extension ${text(extensions.join(", "))}, got ${text(actualExt)}.`
					};
				}
			}
			if (mustNotExist) {
				if (existsSync(input)) return {
					success: false,
					error: options.errors?.pathAlreadyExists ? typeof options.errors.pathAlreadyExists === "function" ? options.errors.pathAlreadyExists(input) : options.errors.pathAlreadyExists : message`Path ${text(input)} already exists.`
				};
				if (allowCreate) {
					const parentDir = dirname(input);
					if (!existsSync(parentDir)) return {
						success: false,
						error: options.errors?.parentNotFound ? typeof options.errors.parentNotFound === "function" ? options.errors.parentNotFound(parentDir) : options.errors.parentNotFound : message`Parent directory ${text(parentDir)} does not exist.`
					};
				}
				return {
					success: true,
					value: input
				};
			}
			if (mustExist) {
				if (!existsSync(input)) return {
					success: false,
					error: options.errors?.pathNotFound ? typeof options.errors.pathNotFound === "function" ? options.errors.pathNotFound(input) : options.errors.pathNotFound : message`Path ${text(input)} does not exist.`
				};
				const stats = statSync(input);
				if (type === "file" && !stats.isFile()) return {
					success: false,
					error: options.errors?.notAFile ? typeof options.errors.notAFile === "function" ? options.errors.notAFile(input) : options.errors.notAFile : message`Expected a file, but ${text(input)} is not a file.`
				};
				if (type === "directory" && !stats.isDirectory()) return {
					success: false,
					error: options.errors?.notADirectory ? typeof options.errors.notADirectory === "function" ? options.errors.notADirectory(input) : options.errors.notADirectory : message`Expected a directory, but ${text(input)} is not a directory.`
				};
			}
			if (allowCreate && !mustExist) {
				const parentDir = dirname(input);
				if (!existsSync(parentDir)) return {
					success: false,
					error: options.errors?.parentNotFound ? typeof options.errors.parentNotFound === "function" ? options.errors.parentNotFound(parentDir) : options.errors.parentNotFound : message`Parent directory ${text(parentDir)} does not exist.`
				};
			}
			return {
				success: true,
				value: input
			};
		},
		format(value) {
			return value;
		},
		*suggest(prefix) {
			yield {
				kind: "file",
				pattern: prefix,
				type: type === "either" ? "any" : type,
				extensions,
				includeHidden: prefix.startsWith("."),
				description: type === "directory" ? message`Directory` : type === "file" ? message`File` : message`File or directory`
			};
		}
	};
}

//#endregion
export { path };