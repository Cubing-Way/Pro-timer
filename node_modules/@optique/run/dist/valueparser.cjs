const require_rolldown_runtime = require('./_virtual/rolldown_runtime.cjs');
const node_path = require_rolldown_runtime.__toESM(require("node:path"));
const __optique_core_message = require_rolldown_runtime.__toESM(require("@optique/core/message"));
const __optique_core_nonempty = require_rolldown_runtime.__toESM(require("@optique/core/nonempty"));
const node_fs = require_rolldown_runtime.__toESM(require("node:fs"));

//#region src/valueparser.ts
/**
* Creates a ValueParser for file system paths with validation options.
*
* This parser provides filesystem validation and type checking for command-line
* path arguments. It can validate existence, file vs directory types, parent
* directory existence for new files, and file extensions.
*
* @param options Configuration options for path validation.
* @returns A ValueParser that validates and returns string paths.
*
* @example
* ```typescript
* import { path } from "@optique/run";
* import { argument, object } from "@optique/core/parser";
*
* // Basic path parser (any path, no validation)
* const configFile = argument(path());
*
* // File must exist
* const inputFile = argument(path({ mustExist: true }));
*
* // Directory must exist
* const outputDir = argument(path({ mustExist: true, type: "directory" }));
*
* // File can be created (parent directory must exist)
* const logFile = argument(path({ type: "file", allowCreate: true }));
*
* // Config files with specific extensions
* const config = argument(path({
*   mustExist: true,
*   type: "file",
*   extensions: [".json", ".yaml", ".yml"]
* }));
* ```
*/
function path(options = {}) {
	const { metavar = "PATH", type = "either", allowCreate = false, extensions } = options;
	(0, __optique_core_nonempty.ensureNonEmptyString)(metavar);
	const mustExist = "mustExist" in options ? options.mustExist : false;
	const mustNotExist = "mustNotExist" in options ? options.mustNotExist : false;
	return {
		metavar,
		parse(input) {
			if (extensions && extensions.length > 0) {
				const ext = (0, node_path.extname)(input);
				if (!extensions.includes(ext)) {
					const actualExt = ext || "no extension";
					return {
						success: false,
						error: options.errors?.invalidExtension ? typeof options.errors.invalidExtension === "function" ? options.errors.invalidExtension(input, extensions, actualExt) : options.errors.invalidExtension : __optique_core_message.message`Expected file with extension ${(0, __optique_core_message.text)(extensions.join(", "))}, got ${(0, __optique_core_message.text)(actualExt)}.`
					};
				}
			}
			if (mustNotExist) {
				if ((0, node_fs.existsSync)(input)) return {
					success: false,
					error: options.errors?.pathAlreadyExists ? typeof options.errors.pathAlreadyExists === "function" ? options.errors.pathAlreadyExists(input) : options.errors.pathAlreadyExists : __optique_core_message.message`Path ${(0, __optique_core_message.text)(input)} already exists.`
				};
				if (allowCreate) {
					const parentDir = (0, node_path.dirname)(input);
					if (!(0, node_fs.existsSync)(parentDir)) return {
						success: false,
						error: options.errors?.parentNotFound ? typeof options.errors.parentNotFound === "function" ? options.errors.parentNotFound(parentDir) : options.errors.parentNotFound : __optique_core_message.message`Parent directory ${(0, __optique_core_message.text)(parentDir)} does not exist.`
					};
				}
				return {
					success: true,
					value: input
				};
			}
			if (mustExist) {
				if (!(0, node_fs.existsSync)(input)) return {
					success: false,
					error: options.errors?.pathNotFound ? typeof options.errors.pathNotFound === "function" ? options.errors.pathNotFound(input) : options.errors.pathNotFound : __optique_core_message.message`Path ${(0, __optique_core_message.text)(input)} does not exist.`
				};
				const stats = (0, node_fs.statSync)(input);
				if (type === "file" && !stats.isFile()) return {
					success: false,
					error: options.errors?.notAFile ? typeof options.errors.notAFile === "function" ? options.errors.notAFile(input) : options.errors.notAFile : __optique_core_message.message`Expected a file, but ${(0, __optique_core_message.text)(input)} is not a file.`
				};
				if (type === "directory" && !stats.isDirectory()) return {
					success: false,
					error: options.errors?.notADirectory ? typeof options.errors.notADirectory === "function" ? options.errors.notADirectory(input) : options.errors.notADirectory : __optique_core_message.message`Expected a directory, but ${(0, __optique_core_message.text)(input)} is not a directory.`
				};
			}
			if (allowCreate && !mustExist) {
				const parentDir = (0, node_path.dirname)(input);
				if (!(0, node_fs.existsSync)(parentDir)) return {
					success: false,
					error: options.errors?.parentNotFound ? typeof options.errors.parentNotFound === "function" ? options.errors.parentNotFound(parentDir) : options.errors.parentNotFound : __optique_core_message.message`Parent directory ${(0, __optique_core_message.text)(parentDir)} does not exist.`
				};
			}
			return {
				success: true,
				value: input
			};
		},
		format(value) {
			return value;
		},
		*suggest(prefix) {
			yield {
				kind: "file",
				pattern: prefix,
				type: type === "either" ? "any" : type,
				extensions,
				includeHidden: prefix.startsWith("."),
				description: type === "directory" ? __optique_core_message.message`Directory` : type === "file" ? __optique_core_message.message`File` : __optique_core_message.message`File or directory`
			};
		}
	};
}

//#endregion
exports.path = path;