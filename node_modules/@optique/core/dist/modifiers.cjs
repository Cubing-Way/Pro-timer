const require_message = require('./message.cjs');

//#region src/modifiers.ts
/**
* Internal helper for optional-style parsing logic shared by optional()
* and withDefault(). Handles the common pattern of:
* - Unwrapping optional state to inner parser state
* - Detecting if inner parser actually matched (state changed or no consumption)
* - Returning success with undefined state when inner parser fails without consuming
* @internal
*/
function parseOptionalStyle(context, parser) {
	const innerState = typeof context.state === "undefined" ? parser.initialState : context.state[0];
	const result = parser.parse({
		...context,
		state: innerState
	});
	if (result.success) {
		if (result.next.state !== innerState || result.consumed.length === 0) return {
			success: true,
			next: {
				...result.next,
				state: [result.next.state]
			},
			consumed: result.consumed
		};
		return {
			success: true,
			next: {
				...result.next,
				state: context.state
			},
			consumed: result.consumed
		};
	}
	if (result.consumed === 0) return {
		success: true,
		next: context,
		consumed: []
	};
	return result;
}
/**
* Creates a parser that makes another parser optional, allowing it to succeed
* without consuming input if the wrapped parser fails to match.
* If the wrapped parser succeeds, this returns its value.
* If the wrapped parser fails, this returns `undefined` without consuming input.
* @template TValue The type of the value returned by the wrapped parser.
* @template TState The type of the state used by the wrapped parser.
* @param parser The {@link Parser} to make optional.
* @returns A {@link Parser} that produces either the result of the wrapped parser
*          or `undefined` if the wrapped parser fails to match.
*/
function optional(parser) {
	return {
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "optional",
			terms: parser.usage
		}],
		initialState: void 0,
		parse(context) {
			return parseOptionalStyle(context, parser);
		},
		complete(state) {
			if (typeof state === "undefined") return {
				success: true,
				value: void 0
			};
			return parser.complete(state[0]);
		},
		suggest(context, prefix) {
			const innerState = typeof context.state === "undefined" ? parser.initialState : context.state[0];
			return parser.suggest({
				...context,
				state: innerState
			}, prefix);
		},
		getDocFragments(state, defaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state === void 0 ? { kind: "unavailable" } : {
				kind: "available",
				state: state.state[0]
			};
			return parser.getDocFragments(innerState, defaultValue);
		}
	};
}
/**
* Error type for structured error messages in {@link withDefault} default value callbacks.
* Unlike regular errors that only support string messages, this error type accepts
* a {@link Message} object that supports rich formatting, colors, and structured content.
*
* @example
* ```typescript
* withDefault(option("--url", url()), () => {
*   if (!process.env.INSTANCE_URL) {
*     throw new WithDefaultError(
*       message`Environment variable ${envVar("INSTANCE_URL")} is not set.`
*     );
*   }
*   return new URL(process.env.INSTANCE_URL);
* })
* ```
*
* @since 0.5.0
*/
var WithDefaultError = class extends Error {
	/**
	* The structured message associated with this error.
	*/
	errorMessage;
	/**
	* Creates a new WithDefaultError with a structured message.
	* @param message The structured {@link Message} describing the error.
	*/
	constructor(message$1) {
		super(require_message.formatMessage(message$1));
		this.errorMessage = message$1;
		this.name = "WithDefaultError";
	}
};
function withDefault(parser, defaultValue, options) {
	return {
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "optional",
			terms: parser.usage
		}],
		initialState: void 0,
		parse(context) {
			return parseOptionalStyle(context, parser);
		},
		complete(state) {
			if (typeof state === "undefined") try {
				const value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
				return {
					success: true,
					value
				};
			} catch (error) {
				return {
					success: false,
					error: error instanceof WithDefaultError ? error.errorMessage : require_message.message`${require_message.text(String(error))}`
				};
			}
			return parser.complete(state[0]);
		},
		suggest(context, prefix) {
			const innerState = typeof context.state === "undefined" ? parser.initialState : context.state[0];
			return parser.suggest({
				...context,
				state: innerState
			}, prefix);
		},
		getDocFragments(state, upperDefaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state === void 0 ? { kind: "unavailable" } : {
				kind: "available",
				state: state.state[0]
			};
			const actualDefaultValue = upperDefaultValue != null ? upperDefaultValue : typeof defaultValue === "function" ? defaultValue() : defaultValue;
			const fragments = parser.getDocFragments(innerState, actualDefaultValue);
			if (options?.message) {
				const modifiedFragments = fragments.fragments.map((fragment) => {
					if (fragment.type === "entry") return {
						...fragment,
						default: options.message
					};
					return fragment;
				});
				return {
					...fragments,
					fragments: modifiedFragments
				};
			}
			return fragments;
		}
	};
}
/**
* Creates a parser that transforms the result value of another parser using
* a mapping function. This enables value transformation while preserving
* the original parser's parsing logic and state management.
*
* The `map()` function is useful for:
* - Converting parsed values to different types
* - Applying transformations like string formatting or boolean inversion
* - Computing derived values from parsed input
* - Creating reusable transformations that can be applied to any parser
*
* @template T The type of the value produced by the original parser.
* @template U The type of the value produced by the mapping function.
* @template TState The type of the state used by the original parser.
* @param parser The {@link Parser} whose result will be transformed.
* @param transform A function that transforms the parsed value from type T to type U.
* @returns A {@link Parser} that produces the transformed value of type U
*          while preserving the original parser's state type and parsing behavior.
*
* @example
* ```typescript
* // Transform boolean flag to its inverse
* const parser = object({
*   disallow: map(option("--allow"), b => !b)
* });
*
* // Transform string to uppercase
* const upperParser = map(argument(string()), s => s.toUpperCase());
*
* // Transform number to formatted string
* const prefixedParser = map(option("-n", integer()), n => `value: ${n}`);
* ```
*/
function map(parser, transform) {
	return {
		$valueType: [],
		$stateType: parser.$stateType,
		priority: parser.priority,
		usage: parser.usage,
		initialState: parser.initialState,
		parse: parser.parse.bind(parser),
		complete(state) {
			const result = parser.complete(state);
			if (result.success) return {
				success: true,
				value: transform(result.value)
			};
			return result;
		},
		suggest(context, prefix) {
			return parser.suggest(context, prefix);
		},
		getDocFragments(state, _defaultValue) {
			return parser.getDocFragments(state, void 0);
		}
	};
}
/**
* Creates a parser that allows multiple occurrences of a given parser.
* This parser can be used to parse multiple values of the same type,
* such as multiple command-line arguments or options.
* @template TValue The type of the value that the parser produces.
* @template TState The type of the state used by the parser.
* @param parser The {@link Parser} to apply multiple times.
* @param options Optional configuration for the parser,
*                allowing you to specify the minimum and maximum number of
*                occurrences allowed.
* @returns A {@link Parser} that produces an array of values
*          of type {@link TValue} and an array of states
*          of type {@link TState}.
*/
function multiple(parser, options = {}) {
	const { min = 0, max = Infinity } = options;
	return {
		$valueType: [],
		$stateType: [],
		priority: parser.priority,
		usage: [{
			type: "multiple",
			terms: parser.usage,
			min
		}],
		initialState: [],
		parse(context) {
			let added = context.state.length < 1;
			let result = parser.parse({
				...context,
				state: context.state.at(-1) ?? parser.initialState
			});
			if (!result.success) if (!added) {
				result = parser.parse({
					...context,
					state: parser.initialState
				});
				if (!result.success) return result;
				added = true;
			} else return result;
			return {
				success: true,
				next: {
					...result.next,
					state: [...added ? context.state : context.state.slice(0, -1), result.next.state]
				},
				consumed: result.consumed
			};
		},
		complete(state) {
			const result = [];
			for (const s of state) {
				const valueResult = parser.complete(s);
				if (valueResult.success) result.push(valueResult.value);
				else return {
					success: false,
					error: valueResult.error
				};
			}
			if (result.length < min) {
				const customMessage = options.errors?.tooFew;
				return {
					success: false,
					error: customMessage ? typeof customMessage === "function" ? customMessage(min, result.length) : customMessage : require_message.message`Expected at least ${require_message.text(min.toLocaleString("en"))} values, but got only ${require_message.text(result.length.toLocaleString("en"))}.`
				};
			} else if (result.length > max) {
				const customMessage = options.errors?.tooMany;
				return {
					success: false,
					error: customMessage ? typeof customMessage === "function" ? customMessage(max, result.length) : customMessage : require_message.message`Expected at most ${require_message.text(max.toLocaleString("en"))} values, but got ${require_message.text(result.length.toLocaleString("en"))}.`
				};
			}
			return {
				success: true,
				value: result
			};
		},
		suggest(context, prefix) {
			const innerState = context.state.length > 0 ? context.state.at(-1) : parser.initialState;
			return parser.suggest({
				...context,
				state: innerState
			}, prefix);
		},
		getDocFragments(state, defaultValue) {
			const innerState = state.kind === "unavailable" ? { kind: "unavailable" } : state.state.length > 0 ? {
				kind: "available",
				state: state.state.at(-1)
			} : { kind: "unavailable" };
			return parser.getDocFragments(innerState, defaultValue != null && defaultValue.length > 0 ? defaultValue[0] : void 0);
		}
	};
}

//#endregion
exports.WithDefaultError = WithDefaultError;
exports.map = map;
exports.multiple = multiple;
exports.optional = optional;
exports.withDefault = withDefault;