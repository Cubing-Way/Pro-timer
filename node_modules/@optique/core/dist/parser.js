import { message } from "./message.js";
import { normalizeUsage } from "./usage.js";
import { DuplicateOptionError, concat, conditional, group, longestMatch, merge, object, or, tuple } from "./constructs.js";
import { WithDefaultError, map, multiple, optional, withDefault } from "./modifiers.js";
import { argument, command, constant, flag, option, passThrough } from "./primitives.js";

//#region src/parser.ts
/**
* Parses an array of command-line arguments using the provided combined parser.
* This function processes the input arguments, applying the parser to each
* argument until all arguments are consumed or an error occurs.
* @template T The type of the value produced by the parser.
* @param parser The combined {@link Parser} to use for parsing the input
*               arguments.
* @param args The array of command-line arguments to parse.  Usually this is
*             `process.argv.slice(2)` in Node.js or `Deno.args` in Deno.
* @returns A {@link Result} object indicating whether the parsing was
*          successful or not.  If successful, it contains the parsed value of
*          type `T`.  If not, it contains an error message describing the
*          failure.
*/
function parse(parser, args) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = parser.parse(context);
		if (!result.success) return {
			success: false,
			error: result.error
		};
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return {
			success: false,
			error: message`Unexpected option or argument: ${context.buffer[0]}.`
		};
	} while (context.buffer.length > 0);
	const endResult = parser.complete(context.state);
	return endResult.success ? {
		success: true,
		value: endResult.value
	} : {
		success: false,
		error: endResult.error
	};
}
/**
* Generates command-line suggestions based on current parsing state.
* This function processes the input arguments up to the last argument,
* then calls the parser's suggest method with the remaining prefix.
* @template T The type of the value produced by the parser.
* @param parser The {@link Parser} to use for generating suggestions.
* @param args The array of command-line arguments including the partial
*             argument to complete.  The last element is treated as
*             the prefix for suggestions.
* @returns An array of {@link Suggestion} objects containing completion
*          candidates.
* @example
* ```typescript
* const parser = object({
*   verbose: option("-v", "--verbose"),
*   format: option("-f", "--format", choice(["json", "yaml"]))
* });
*
* // Get suggestions for options starting with "--"
* const suggestions = suggest(parser, ["--"]);
* // Returns: [{ text: "--verbose" }, { text: "--format" }]
*
* // Get suggestions after parsing some arguments
* const suggestions2 = suggest(parser, ["-v", "--format="]);
* // Returns: [{ text: "--format=json" }, { text: "--format=yaml" }]
* ```
* @since 0.6.0
*/
function suggest(parser, args) {
	const allButLast = args.slice(0, -1);
	const prefix = args[args.length - 1];
	let context = {
		buffer: allButLast,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	while (context.buffer.length > 0) {
		const result = parser.parse(context);
		if (!result.success) return Array.from(parser.suggest(context, prefix));
		const previousBuffer = context.buffer;
		context = result.next;
		if (context.buffer.length > 0 && context.buffer.length === previousBuffer.length && context.buffer.every((item, i) => item === previousBuffer[i])) return [];
	}
	return Array.from(parser.suggest(context, prefix));
}
/**
* Generates a documentation page for a parser based on its current state after
* attempting to parse the provided arguments. This function is useful for
* creating help documentation that reflects the current parsing context.
*
* The function works by:
* 1. Attempting to parse the provided arguments to determine the current state
* 2. Generating documentation fragments from the parser's current state
* 3. Organizing fragments into entries and sections
* 4. Resolving command usage terms based on parsed arguments
*
* @param parser The parser to generate documentation for
* @param args Optional array of command-line arguments that have been parsed
*             so far. Defaults to an empty array. This is used to determine
*             the current parsing context and generate contextual documentation.
* @returns A {@link DocPage} containing usage information, sections, and
*          optional description, or `undefined` if no documentation can be
*          generated.
*
* @example
* ```typescript
* const parser = object({
*   verbose: option("-v", "--verbose"),
*   port: option("-p", "--port", integer())
* });
*
* // Get documentation for the root parser
* const rootDoc = getDocPage(parser);
*
* // Get documentation after parsing some arguments
* const contextDoc = getDocPage(parser, ["-v"]);
* ```
*/
function getDocPage(parser, args = []) {
	let context = {
		buffer: args,
		optionsTerminated: false,
		state: parser.initialState,
		usage: parser.usage
	};
	do {
		const result = parser.parse(context);
		if (!result.success) break;
		context = result.next;
	} while (context.buffer.length > 0);
	const { description, fragments, footer } = parser.getDocFragments({
		kind: "available",
		state: context.state
	}, void 0);
	const entries = fragments.filter((f) => f.type === "entry");
	const sections = [];
	for (const fragment of fragments) {
		if (fragment.type !== "section") continue;
		if (fragment.title == null) entries.push(...fragment.entries);
		else sections.push(fragment);
	}
	if (entries.length > 0) sections.push({ entries });
	const usage = [...normalizeUsage(parser.usage)];
	let i = 0;
	for (const arg of args) {
		if (i >= usage.length) break;
		const term = usage[i];
		if (term.type === "exclusive") {
			for (const termGroup of term.terms) {
				const firstTerm = termGroup[0];
				if (firstTerm?.type !== "command" || firstTerm.name !== arg) continue;
				usage.splice(i, 1, ...termGroup);
				i += termGroup.length;
				break;
			}
			if (usage[i] === term) i++;
		} else i++;
	}
	return {
		usage,
		sections,
		...description != null && { description },
		...footer != null && { footer }
	};
}

//#endregion
export { DuplicateOptionError, WithDefaultError, argument, command, concat, conditional, constant, flag, getDocPage, group, longestMatch, map, merge, multiple, object, option, optional, or, parse, passThrough, suggest, tuple, withDefault };