const require_message = require('./message.cjs');
const require_usage = require('./usage.cjs');
const require_suggestion = require('./suggestion.cjs');
const require_valueparser = require('./valueparser.cjs');

//#region src/primitives.ts
/**
* Creates a parser that always succeeds without consuming any input and
* produces a constant value of the type {@link T}.
* @template T The type of the constant value produced by the parser.
*/
function constant(value) {
	return {
		$valueType: [],
		$stateType: [],
		priority: 0,
		usage: [],
		initialState: value,
		parse(context) {
			return {
				success: true,
				next: context,
				consumed: []
			};
		},
		complete(state) {
			return {
				success: true,
				value: state
			};
		},
		suggest(_context, _prefix) {
			return [];
		},
		getDocFragments(_state, _defaultValue) {
			return { fragments: [] };
		}
	};
}
function option(...args) {
	const lastArg = args.at(-1);
	const secondLastArg = args.at(-2);
	let valueParser;
	let optionNames$1;
	let options = {};
	if (require_valueparser.isValueParser(lastArg)) {
		valueParser = lastArg;
		optionNames$1 = args.slice(0, -1);
	} else if (typeof lastArg === "object" && lastArg != null) {
		options = lastArg;
		if (require_valueparser.isValueParser(secondLastArg)) {
			valueParser = secondLastArg;
			optionNames$1 = args.slice(0, -2);
		} else {
			valueParser = void 0;
			optionNames$1 = args.slice(0, -1);
		}
	} else {
		optionNames$1 = args;
		valueParser = void 0;
	}
	return {
		$valueType: [],
		$stateType: [],
		priority: 10,
		usage: [valueParser == null ? {
			type: "optional",
			terms: [{
				type: "option",
				names: optionNames$1,
				...options.hidden && { hidden: true }
			}]
		} : {
			type: "option",
			names: optionNames$1,
			metavar: valueParser.metavar,
			...options.hidden && { hidden: true }
		}],
		initialState: valueParser == null ? {
			success: true,
			value: false
		} : {
			success: false,
			error: options.errors?.missing ? typeof options.errors.missing === "function" ? options.errors.missing(optionNames$1) : options.errors.missing : require_message.message`Missing option ${require_message.optionNames(optionNames$1)}.`
		},
		parse(context) {
			if (context.optionsTerminated) return {
				success: false,
				consumed: 0,
				error: options.errors?.optionsTerminated ?? require_message.message`No more options can be parsed.`
			};
			else if (context.buffer.length < 1) return {
				success: false,
				consumed: 0,
				error: options.errors?.endOfInput ?? require_message.message`Expected an option, but got end of input.`
			};
			if (context.buffer[0] === "--") return {
				success: true,
				next: {
					...context,
					buffer: context.buffer.slice(1),
					state: context.state,
					optionsTerminated: true
				},
				consumed: context.buffer.slice(0, 1)
			};
			if (optionNames$1.includes(context.buffer[0])) {
				if (context.state.success && (valueParser != null || context.state.value)) return {
					success: false,
					consumed: 1,
					error: options.errors?.duplicate ? typeof options.errors.duplicate === "function" ? options.errors.duplicate(context.buffer[0]) : options.errors.duplicate : require_message.message`${require_message.optionName(context.buffer[0])} cannot be used multiple times.`
				};
				if (valueParser == null) return {
					success: true,
					next: {
						...context,
						state: {
							success: true,
							value: true
						},
						buffer: context.buffer.slice(1)
					},
					consumed: context.buffer.slice(0, 1)
				};
				if (context.buffer.length < 2) return {
					success: false,
					consumed: 1,
					error: require_message.message`Option ${require_message.optionName(context.buffer[0])} requires a value, but got no value.`
				};
				const result = valueParser.parse(context.buffer[1]);
				return {
					success: true,
					next: {
						...context,
						state: result,
						buffer: context.buffer.slice(2)
					},
					consumed: context.buffer.slice(0, 2)
				};
			}
			const prefixes = optionNames$1.filter((name) => name.startsWith("--") || name.startsWith("/")).map((name) => name.startsWith("/") ? `${name}:` : `${name}=`);
			for (const prefix of prefixes) {
				if (!context.buffer[0].startsWith(prefix)) continue;
				if (context.state.success && (valueParser != null || context.state.value)) return {
					success: false,
					consumed: 1,
					error: options.errors?.duplicate ? typeof options.errors.duplicate === "function" ? options.errors.duplicate(prefix) : options.errors.duplicate : require_message.message`${require_message.optionName(prefix)} cannot be used multiple times.`
				};
				const value = context.buffer[0].slice(prefix.length);
				if (valueParser == null) return {
					success: false,
					consumed: 1,
					error: options.errors?.unexpectedValue ? typeof options.errors.unexpectedValue === "function" ? options.errors.unexpectedValue(value) : options.errors.unexpectedValue : require_message.message`Option ${require_message.optionName(prefix)} is a Boolean flag, but got a value: ${value}.`
				};
				const result = valueParser.parse(value);
				return {
					success: true,
					next: {
						...context,
						state: result,
						buffer: context.buffer.slice(1)
					},
					consumed: context.buffer.slice(0, 1)
				};
			}
			if (valueParser == null) {
				const shortOptions = optionNames$1.filter((name) => name.match(/^-[^-]$/));
				for (const shortOption of shortOptions) {
					if (!context.buffer[0].startsWith(shortOption)) continue;
					if (context.state.success && (valueParser != null || context.state.value)) return {
						success: false,
						consumed: 1,
						error: options.errors?.duplicate ? typeof options.errors.duplicate === "function" ? options.errors.duplicate(shortOption) : options.errors.duplicate : require_message.message`${require_message.optionName(shortOption)} cannot be used multiple times.`
					};
					return {
						success: true,
						next: {
							...context,
							state: {
								success: true,
								value: true
							},
							buffer: [`-${context.buffer[0].slice(2)}`, ...context.buffer.slice(1)]
						},
						consumed: [context.buffer[0].slice(0, 2)]
					};
				}
			}
			const invalidOption = context.buffer[0];
			if (options.errors?.noMatch) {
				const candidates = /* @__PURE__ */ new Set();
				for (const name of require_usage.extractOptionNames(context.usage)) candidates.add(name);
				const suggestions = require_suggestion.findSimilar(invalidOption, candidates, require_suggestion.DEFAULT_FIND_SIMILAR_OPTIONS);
				const errorMessage = typeof options.errors.noMatch === "function" ? options.errors.noMatch(invalidOption, suggestions) : options.errors.noMatch;
				return {
					success: false,
					consumed: 0,
					error: errorMessage
				};
			}
			const baseError = require_message.message`No matched option for ${require_message.optionName(invalidOption)}.`;
			return {
				success: false,
				consumed: 0,
				error: require_suggestion.createErrorWithSuggestions(baseError, invalidOption, context.usage, "option")
			};
		},
		complete(state) {
			if (state == null) return valueParser == null ? {
				success: true,
				value: false
			} : {
				success: false,
				error: options.errors?.missing ? typeof options.errors.missing === "function" ? options.errors.missing(optionNames$1) : options.errors.missing : require_message.message`Missing option ${require_message.optionNames(optionNames$1)}.`
			};
			if (state.success) return state;
			return {
				success: false,
				error: options.errors?.invalidValue ? typeof options.errors.invalidValue === "function" ? options.errors.invalidValue(state.error) : options.errors.invalidValue : require_message.message`${require_message.optionNames(optionNames$1)}: ${state.error}`
			};
		},
		suggest(context, prefix) {
			if (options.hidden) return [];
			const suggestions = [];
			const equalsIndex = prefix.indexOf("=");
			if (equalsIndex >= 0) {
				const optionPart = prefix.slice(0, equalsIndex);
				const valuePart = prefix.slice(equalsIndex + 1);
				if (optionNames$1.includes(optionPart)) {
					if (valueParser && valueParser.suggest) {
						const valueSuggestions = valueParser.suggest(valuePart);
						for (const suggestion of valueSuggestions) if (suggestion.kind === "literal") suggestions.push({
							kind: "literal",
							text: `${optionPart}=${suggestion.text}`,
							description: suggestion.description
						});
						else suggestions.push({
							kind: "literal",
							text: `${optionPart}=${suggestion.pattern || ""}`,
							description: suggestion.description
						});
					}
				}
			} else {
				if (prefix.startsWith("--") || prefix.startsWith("-") || prefix.startsWith("/")) {
					for (const optionName$1 of optionNames$1) if (optionName$1.startsWith(prefix)) {
						if (prefix === "-" && optionName$1.length !== 2) continue;
						suggestions.push({
							kind: "literal",
							text: optionName$1
						});
					}
				}
				if (valueParser && valueParser.suggest) {
					let shouldSuggestValues = false;
					if (context.buffer.length > 0) {
						const lastToken = context.buffer[context.buffer.length - 1];
						if (optionNames$1.includes(lastToken)) shouldSuggestValues = true;
					} else if (context.state === void 0 && context.buffer.length === 0) shouldSuggestValues = true;
					if (shouldSuggestValues) {
						const valueSuggestions = valueParser.suggest(prefix);
						suggestions.push(...valueSuggestions);
					}
				}
			}
			return suggestions;
		},
		getDocFragments(_state, defaultValue) {
			if (options.hidden) return {
				fragments: [],
				description: options.description
			};
			const fragments = [{
				type: "entry",
				term: {
					type: "option",
					names: optionNames$1,
					metavar: valueParser?.metavar
				},
				description: options.description,
				default: defaultValue != null && valueParser != null ? require_message.message`${valueParser.format(defaultValue)}` : void 0
			}];
			return {
				fragments,
				description: options.description
			};
		},
		[Symbol.for("Deno.customInspect")]() {
			return `option(${optionNames$1.map((o) => JSON.stringify(o)).join(", ")})`;
		}
	};
}
/**
* Creates a parser for command-line flags that must be explicitly provided.
* Unlike {@link option}, this parser fails if the flag is not present, making
* it suitable for required boolean flags that don't have a meaningful default.
*
* The key difference from {@link option} is:
* - {@link option} without a value parser: Returns `false` when not present
* - {@link flag}: Fails parsing when not present, only produces `true`
*
* This is useful for dependent options where the presence of a flag changes
* the shape of the result type.
*
* @param args The {@link OptionName}s to parse, followed by an optional
*             {@link FlagOptions} object that allows you to specify
*             a description or other metadata.
* @returns A {@link Parser} that produces `true` when the flag is present
*          and fails when it is not present.
*
* @example
* ```typescript
* // Basic flag usage
* const parser = flag("-f", "--force");
* // Succeeds with true: parse(parser, ["-f"])
* // Fails: parse(parser, [])
*
* // With description
* const verboseFlag = flag("-v", "--verbose", {
*   description: "Enable verbose output"
* });
* ```
*/
function flag(...args) {
	const lastArg = args.at(-1);
	let optionNames$1;
	let options = {};
	if (typeof lastArg === "object" && lastArg != null && !Array.isArray(lastArg)) {
		options = lastArg;
		optionNames$1 = args.slice(0, -1);
	} else optionNames$1 = args;
	return {
		$valueType: [],
		$stateType: [],
		priority: 10,
		usage: [{
			type: "option",
			names: optionNames$1,
			...options.hidden && { hidden: true }
		}],
		initialState: void 0,
		parse(context) {
			if (context.optionsTerminated) return {
				success: false,
				consumed: 0,
				error: options.errors?.optionsTerminated ?? require_message.message`No more options can be parsed.`
			};
			else if (context.buffer.length < 1) return {
				success: false,
				consumed: 0,
				error: options.errors?.endOfInput ?? require_message.message`Expected an option, but got end of input.`
			};
			if (context.buffer[0] === "--") return {
				success: true,
				next: {
					...context,
					buffer: context.buffer.slice(1),
					state: context.state,
					optionsTerminated: true
				},
				consumed: context.buffer.slice(0, 1)
			};
			if (optionNames$1.includes(context.buffer[0])) {
				if (context.state?.success) return {
					success: false,
					consumed: 1,
					error: options.errors?.duplicate ? typeof options.errors.duplicate === "function" ? options.errors.duplicate(context.buffer[0]) : options.errors.duplicate : require_message.message`${require_message.optionName(context.buffer[0])} cannot be used multiple times.`
				};
				return {
					success: true,
					next: {
						...context,
						state: {
							success: true,
							value: true
						},
						buffer: context.buffer.slice(1)
					},
					consumed: context.buffer.slice(0, 1)
				};
			}
			const prefixes = optionNames$1.filter((name) => name.startsWith("--") || name.startsWith("/")).map((name) => name.startsWith("/") ? `${name}:` : `${name}=`);
			for (const prefix of prefixes) if (context.buffer[0].startsWith(prefix)) {
				const value = context.buffer[0].slice(prefix.length);
				return {
					success: false,
					consumed: 1,
					error: require_message.message`Flag ${require_message.optionName(prefix.slice(0, -1))} does not accept a value, but got: ${value}.`
				};
			}
			const shortOptions = optionNames$1.filter((name) => name.match(/^-[^-]$/));
			for (const shortOption of shortOptions) {
				if (!context.buffer[0].startsWith(shortOption)) continue;
				if (context.state?.success) return {
					success: false,
					consumed: 1,
					error: options.errors?.duplicate ? typeof options.errors.duplicate === "function" ? options.errors.duplicate(shortOption) : options.errors.duplicate : require_message.message`${require_message.optionName(shortOption)} cannot be used multiple times.`
				};
				return {
					success: true,
					next: {
						...context,
						state: {
							success: true,
							value: true
						},
						buffer: [`-${context.buffer[0].slice(2)}`, ...context.buffer.slice(1)]
					},
					consumed: [context.buffer[0].slice(0, 2)]
				};
			}
			const invalidOption = context.buffer[0];
			if (options.errors?.noMatch) {
				const candidates = /* @__PURE__ */ new Set();
				for (const name of require_usage.extractOptionNames(context.usage)) candidates.add(name);
				const suggestions = require_suggestion.findSimilar(invalidOption, candidates, require_suggestion.DEFAULT_FIND_SIMILAR_OPTIONS);
				const errorMessage = typeof options.errors.noMatch === "function" ? options.errors.noMatch(invalidOption, suggestions) : options.errors.noMatch;
				return {
					success: false,
					consumed: 0,
					error: errorMessage
				};
			}
			const baseError = require_message.message`No matched option for ${require_message.optionName(invalidOption)}.`;
			return {
				success: false,
				consumed: 0,
				error: require_suggestion.createErrorWithSuggestions(baseError, invalidOption, context.usage, "option")
			};
		},
		complete(state) {
			if (state == null) return {
				success: false,
				error: options.errors?.missing ? typeof options.errors.missing === "function" ? options.errors.missing(optionNames$1) : options.errors.missing : require_message.message`Required flag ${require_message.optionNames(optionNames$1)} is missing.`
			};
			if (state.success) return {
				success: true,
				value: true
			};
			return {
				success: false,
				error: require_message.message`${require_message.optionNames(optionNames$1)}: ${state.error}`
			};
		},
		suggest(_context, prefix) {
			if (options.hidden) return [];
			const suggestions = [];
			if (prefix.startsWith("--") || prefix.startsWith("-") || prefix.startsWith("/")) {
				for (const optionName$1 of optionNames$1) if (optionName$1.startsWith(prefix)) {
					if (prefix === "-" && optionName$1.length !== 2) continue;
					suggestions.push({
						kind: "literal",
						text: optionName$1
					});
				}
			}
			return suggestions;
		},
		getDocFragments(_state, _defaultValue) {
			if (options.hidden) return {
				fragments: [],
				description: options.description
			};
			const fragments = [{
				type: "entry",
				term: {
					type: "option",
					names: optionNames$1
				},
				description: options.description
			}];
			return {
				fragments,
				description: options.description
			};
		},
		[Symbol.for("Deno.customInspect")]() {
			return `flag(${optionNames$1.map((o) => JSON.stringify(o)).join(", ")})`;
		}
	};
}
/**
* Creates a parser that expects a single argument value.
* This parser is typically used for positional arguments
* that are not options or flags.
* @template T The type of the value produced by the parser.
* @param valueParser The {@link ValueParser} that defines how to parse
*                    the argument value.
* @param options Optional configuration for the argument parser,
*                allowing you to specify a description or other metadata.
* @returns A {@link Parser} that expects a single argument value and produces
*          the parsed value of type {@link T}.
*/
function argument(valueParser, options = {}) {
	const optionPattern = /^--?[a-z0-9-]+$/i;
	const term = {
		type: "argument",
		metavar: valueParser.metavar,
		...options.hidden && { hidden: true }
	};
	return {
		$valueType: [],
		$stateType: [],
		priority: 5,
		usage: [term],
		initialState: void 0,
		parse(context) {
			if (context.buffer.length < 1) return {
				success: false,
				consumed: 0,
				error: options.errors?.endOfInput ?? require_message.message`Expected an argument, but got end of input.`
			};
			let i = 0;
			let optionsTerminated = context.optionsTerminated;
			if (!optionsTerminated) {
				if (context.buffer[i] === "--") {
					optionsTerminated = true;
					i++;
				} else if (context.buffer[i].match(optionPattern)) return {
					success: false,
					consumed: i,
					error: require_message.message`Expected an argument, but got an option: ${require_message.optionName(context.buffer[i])}.`
				};
			}
			if (context.buffer.length < i + 1) return {
				success: false,
				consumed: i,
				error: require_message.message`Expected an argument, but got end of input.`
			};
			if (context.state != null) return {
				success: false,
				consumed: i,
				error: options.errors?.multiple ? typeof options.errors.multiple === "function" ? options.errors.multiple(valueParser.metavar) : options.errors.multiple : require_message.message`The argument ${require_message.metavar(valueParser.metavar)} cannot be used multiple times.`
			};
			const result = valueParser.parse(context.buffer[i]);
			return {
				success: true,
				next: {
					...context,
					buffer: context.buffer.slice(i + 1),
					state: result,
					optionsTerminated
				},
				consumed: context.buffer.slice(0, i + 1)
			};
		},
		complete(state) {
			if (state == null) return {
				success: false,
				error: options.errors?.endOfInput ?? require_message.message`Expected a ${require_message.metavar(valueParser.metavar)}, but too few arguments.`
			};
			else if (state.success) return state;
			return {
				success: false,
				error: options.errors?.invalidValue ? typeof options.errors.invalidValue === "function" ? options.errors.invalidValue(state.error) : options.errors.invalidValue : require_message.message`${require_message.metavar(valueParser.metavar)}: ${state.error}`
			};
		},
		suggest(_context, prefix) {
			if (options.hidden) return [];
			const suggestions = [];
			if (valueParser.suggest) {
				const valueSuggestions = valueParser.suggest(prefix);
				suggestions.push(...valueSuggestions);
			}
			return suggestions;
		},
		getDocFragments(_state, defaultValue) {
			if (options.hidden) return {
				fragments: [],
				description: options.description
			};
			const fragments = [{
				type: "entry",
				term,
				description: options.description,
				default: defaultValue == null ? void 0 : require_message.message`${valueParser.format(defaultValue)}`
			}];
			return {
				fragments,
				description: options.description
			};
		},
		[Symbol.for("Deno.customInspect")]() {
			return `argument()`;
		}
	};
}
/**
* Creates a parser that matches a specific subcommand name and then applies
* an inner parser to the remaining arguments.
* This is useful for building CLI tools with subcommands like git, npm, etc.
* @template T The type of the value returned by the inner parser.
* @template TState The type of the state used by the inner parser.
* @param name The subcommand name to match (e.g., `"show"`, `"edit"`).
* @param parser The {@link Parser} to apply after the command is matched.
* @param options Optional configuration for the command parser, such as
*                a description for documentation.
* @returns A {@link Parser} that matches the command name and delegates
*          to the inner parser for the remaining arguments.
*/
function command(name, parser, options = {}) {
	return {
		$valueType: [],
		$stateType: [],
		priority: 15,
		usage: [{
			type: "command",
			name,
			...options.hidden && { hidden: true }
		}, ...parser.usage],
		initialState: void 0,
		parse(context) {
			if (context.state === void 0) {
				if (context.buffer.length < 1 || context.buffer[0] !== name) {
					const actual = context.buffer.length > 0 ? context.buffer[0] : null;
					if (options.errors?.notMatched) {
						const errorMessage = options.errors.notMatched;
						const candidates = /* @__PURE__ */ new Set();
						for (const cmdName of require_usage.extractCommandNames(context.usage)) candidates.add(cmdName);
						const suggestions = actual ? require_suggestion.findSimilar(actual, candidates, require_suggestion.DEFAULT_FIND_SIMILAR_OPTIONS) : [];
						return {
							success: false,
							consumed: 0,
							error: typeof errorMessage === "function" ? errorMessage(name, actual, suggestions) : errorMessage
						};
					}
					if (actual == null) return {
						success: false,
						consumed: 0,
						error: require_message.message`Expected command ${require_message.optionName(name)}, but got end of input.`
					};
					const baseError = require_message.message`Expected command ${require_message.optionName(name)}, but got ${actual}.`;
					return {
						success: false,
						consumed: 0,
						error: require_suggestion.createErrorWithSuggestions(baseError, actual, context.usage, "command")
					};
				}
				return {
					success: true,
					next: {
						...context,
						buffer: context.buffer.slice(1),
						state: ["matched", name]
					},
					consumed: context.buffer.slice(0, 1)
				};
			} else if (context.state[0] === "matched") {
				const result = parser.parse({
					...context,
					state: parser.initialState
				});
				if (result.success) return {
					success: true,
					next: {
						...result.next,
						state: ["parsing", result.next.state]
					},
					consumed: result.consumed
				};
				return result;
			} else if (context.state[0] === "parsing") {
				const result = parser.parse({
					...context,
					state: context.state[1]
				});
				if (result.success) return {
					success: true,
					next: {
						...result.next,
						state: ["parsing", result.next.state]
					},
					consumed: result.consumed
				};
				return result;
			}
			return {
				success: false,
				consumed: 0,
				error: options.errors?.invalidState ?? require_message.message`Invalid command state.`
			};
		},
		complete(state) {
			if (typeof state === "undefined") return {
				success: false,
				error: options.errors?.notFound ?? require_message.message`Command ${require_message.optionName(name)} was not matched.`
			};
			else if (state[0] === "matched") return parser.complete(parser.initialState);
			else if (state[0] === "parsing") return parser.complete(state[1]);
			return {
				success: false,
				error: options.errors?.invalidState ?? require_message.message`Invalid command state during completion.`
			};
		},
		suggest(context, prefix) {
			if (options.hidden) return [];
			const suggestions = [];
			if (context.state === void 0) {
				if (name.startsWith(prefix)) suggestions.push({
					kind: "literal",
					text: name,
					...options.description && { description: options.description }
				});
			} else if (context.state[0] === "matched") {
				const innerSuggestions = parser.suggest({
					...context,
					state: parser.initialState
				}, prefix);
				suggestions.push(...innerSuggestions);
			} else if (context.state[0] === "parsing") {
				const innerSuggestions = parser.suggest({
					...context,
					state: context.state[1]
				}, prefix);
				suggestions.push(...innerSuggestions);
			}
			return suggestions;
		},
		getDocFragments(state, defaultValue) {
			if (options.hidden) return {
				fragments: [],
				description: options.description
			};
			if (state.kind === "unavailable" || typeof state.state === "undefined") return {
				description: options.description,
				fragments: [{
					type: "entry",
					term: {
						type: "command",
						name
					},
					description: options.brief ?? options.description
				}]
			};
			const innerState = state.state[0] === "parsing" ? {
				kind: "available",
				state: state.state[1]
			} : { kind: "unavailable" };
			const innerFragments = parser.getDocFragments(innerState, defaultValue);
			return {
				...innerFragments,
				description: innerFragments.description ?? options.description,
				footer: innerFragments.footer ?? options.footer
			};
		},
		[Symbol.for("Deno.customInspect")]() {
			return `command(${JSON.stringify(name)})`;
		}
	};
}
/**
* Creates a parser that collects unrecognized options and passes them through.
* This is useful for building wrapper CLI tools that need to forward unknown
* options to an underlying tool.
*
* **Important**: This parser intentionally weakens Optique's strict parsing
* philosophy where "all input must be recognized." The benefit is enabling
* legitimate wrapper/proxy tool patterns, but the trade-off is that typos
* in pass-through options won't be caught.
*
* @param options Configuration for how to capture options.
* @returns A {@link Parser} that captures unrecognized options as an array
*          of strings.
*
* @example
* ```typescript
* // Default format: only captures --opt=val
* const parser = object({
*   debug: option("--debug"),
*   extra: passThrough(),
* });
*
* // mycli --debug --foo=bar --baz=qux
* // → { debug: true, extra: ["--foo=bar", "--baz=qux"] }
*
* // nextToken format: captures --opt val pairs
* const parser = object({
*   debug: option("--debug"),
*   extra: passThrough({ format: "nextToken" }),
* });
*
* // mycli --debug --foo bar
* // → { debug: true, extra: ["--foo", "bar"] }
*
* // greedy format: captures all remaining tokens
* const parser = command("exec", object({
*   container: argument(string()),
*   args: passThrough({ format: "greedy" }),
* }));
*
* // myproxy exec mycontainer --verbose -it bash
* // → { container: "mycontainer", args: ["--verbose", "-it", "bash"] }
* ```
*
* @since 0.8.0
*/
function passThrough(options = {}) {
	const format = options.format ?? "equalsOnly";
	const optionPattern = /^-[a-z0-9-]|^--[a-z0-9-]+/i;
	const equalsOptionPattern = /^--[a-z0-9-]+=/i;
	return {
		$valueType: [],
		$stateType: [],
		priority: -10,
		usage: [{
			type: "passthrough",
			...options.hidden && { hidden: true }
		}],
		initialState: [],
		parse(context) {
			if (context.buffer.length < 1) return {
				success: false,
				consumed: 0,
				error: require_message.message`No input to pass through.`
			};
			const token = context.buffer[0];
			if (format === "greedy") {
				const captured = [...context.buffer];
				return {
					success: true,
					next: {
						...context,
						buffer: [],
						state: [...context.state, ...captured]
					},
					consumed: captured
				};
			}
			if (context.optionsTerminated) return {
				success: false,
				consumed: 0,
				error: require_message.message`Options terminated; cannot capture pass-through options.`
			};
			if (format === "equalsOnly") {
				if (!equalsOptionPattern.test(token)) return {
					success: false,
					consumed: 0,
					error: require_message.message`Expected --option=value format, but got: ${token}.`
				};
				return {
					success: true,
					next: {
						...context,
						buffer: context.buffer.slice(1),
						state: [...context.state, token]
					},
					consumed: [token]
				};
			}
			if (format === "nextToken") {
				if (!optionPattern.test(token)) return {
					success: false,
					consumed: 0,
					error: require_message.message`Expected option, but got: ${token}.`
				};
				if (token.includes("=")) return {
					success: true,
					next: {
						...context,
						buffer: context.buffer.slice(1),
						state: [...context.state, token]
					},
					consumed: [token]
				};
				const nextToken = context.buffer[1];
				if (nextToken !== void 0 && !optionPattern.test(nextToken)) return {
					success: true,
					next: {
						...context,
						buffer: context.buffer.slice(2),
						state: [
							...context.state,
							token,
							nextToken
						]
					},
					consumed: [token, nextToken]
				};
				return {
					success: true,
					next: {
						...context,
						buffer: context.buffer.slice(1),
						state: [...context.state, token]
					},
					consumed: [token]
				};
			}
			return {
				success: false,
				consumed: 0,
				error: require_message.message`Unknown passThrough format: ${format}.`
			};
		},
		complete(state) {
			return {
				success: true,
				value: state
			};
		},
		suggest(_context, _prefix) {
			return [];
		},
		getDocFragments(_state, _defaultValue) {
			if (options.hidden) return {
				fragments: [],
				description: options.description
			};
			return {
				fragments: [{
					type: "entry",
					term: { type: "passthrough" },
					description: options.description
				}],
				description: options.description
			};
		},
		[Symbol.for("Deno.customInspect")]() {
			return `passThrough(${format})`;
		}
	};
}

//#endregion
exports.argument = argument;
exports.command = command;
exports.constant = constant;
exports.flag = flag;
exports.option = option;
exports.passThrough = passThrough;