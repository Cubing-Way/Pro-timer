import { message, optionName, values } from "./message.js";
import { extractArgumentMetavars, extractCommandNames, extractOptionNames } from "./usage.js";
import { createErrorWithSuggestions, deduplicateSuggestions } from "./suggestion.js";

//#region src/constructs.ts
/**
* Checks if the given token is an option name that requires a value
* (i.e., has a metavar) within the given usage terms.
* @param usage The usage terms to search through.
* @param token The token to check.
* @returns `true` if the token is an option that requires a value, `false` otherwise.
*/
function isOptionRequiringValue(usage, token) {
	function traverse(terms) {
		if (!terms || !Array.isArray(terms)) return false;
		for (const term of terms) if (term.type === "option") {
			if (term.metavar && term.names.includes(token)) return true;
		} else if (term.type === "optional" || term.type === "multiple") {
			if (traverse(term.terms)) return true;
		} else if (term.type === "exclusive") {
			for (const exclusiveUsage of term.terms) if (traverse(exclusiveUsage)) return true;
		}
		return false;
	}
	return traverse(usage);
}
/**
* Extracts required (non-optional) usage terms from a usage array.
* @param usage The usage to extract required terms from
* @returns Usage containing only required (non-optional) terms
*/
function extractRequiredUsage(usage) {
	const required = [];
	for (const term of usage) if (term.type === "optional") continue;
	else if (term.type === "exclusive") {
		const requiredBranches = term.terms.map((branch) => extractRequiredUsage(branch)).filter((branch) => branch.length > 0);
		if (requiredBranches.length > 0) required.push({
			type: "exclusive",
			terms: requiredBranches
		});
	} else if (term.type === "multiple") {
		if (term.min > 0) {
			const requiredTerms = extractRequiredUsage(term.terms);
			if (requiredTerms.length > 0) required.push({
				type: "multiple",
				terms: requiredTerms,
				min: term.min
			});
		}
	} else required.push(term);
	return required;
}
/**
* Analyzes parsers to determine what types of inputs are expected.
* @param parsers The parsers being combined
* @returns Context about what types of inputs are expected
*/
function analyzeNoMatchContext(parsers) {
	const combinedUsage = [{
		type: "exclusive",
		terms: parsers.map((p) => p.usage)
	}];
	const requiredUsage = extractRequiredUsage(combinedUsage);
	return {
		hasOptions: extractOptionNames(requiredUsage).size > 0,
		hasCommands: extractCommandNames(requiredUsage).size > 0,
		hasArguments: extractArgumentMetavars(requiredUsage).size > 0
	};
}
/**
* Error class thrown when duplicate option names are detected during parser
* construction. This is a programmer error, not a user error.
*/
var DuplicateOptionError = class extends Error {
	constructor(optionName$1, sources) {
		super(`Duplicate option name "${optionName$1}" found in fields: ${sources.join(", ")}. Each option name must be unique within a parser combinator.`);
		this.optionName = optionName$1;
		this.sources = sources;
		this.name = "DuplicateOptionError";
	}
};
/**
* Checks for duplicate option names across parser sources and throws an error
* if duplicates are found. This should be called at construction time.
* @param parserSources Array of [source, usage] tuples
* @throws DuplicateOptionError if duplicate option names are found
*/
function checkDuplicateOptionNames(parserSources) {
	const optionNameSources = /* @__PURE__ */ new Map();
	for (const [source, usage] of parserSources) {
		const names = extractOptionNames(usage);
		for (const name of names) {
			if (!optionNameSources.has(name)) optionNameSources.set(name, []);
			optionNameSources.get(name).push(source);
		}
	}
	for (const [name, sources] of optionNameSources) if (sources.length > 1) throw new DuplicateOptionError(name, sources);
}
/**
* Generates a contextual error message based on what types of inputs
* the parsers expect (options, commands, or arguments).
* @param context Context about what types of inputs are expected
* @returns An appropriate error message
*/
function generateNoMatchError(context) {
	const { hasOptions, hasCommands, hasArguments } = context;
	if (hasArguments && !hasOptions && !hasCommands) return message`Missing required argument.`;
	else if (hasCommands && !hasOptions && !hasArguments) return message`No matching command found.`;
	else if (hasOptions && !hasCommands && !hasArguments) return message`No matching option found.`;
	else if (hasCommands && hasOptions && !hasArguments) return message`No matching option or command found.`;
	else if (hasArguments && hasOptions && !hasCommands) return message`No matching option or argument found.`;
	else if (hasArguments && hasCommands && !hasOptions) return message`No matching command or argument found.`;
	else return message`No matching option, command, or argument found.`;
}
/**
* Creates a complete() method shared by or() and longestMatch().
* @internal
*/
function createExclusiveComplete(parsers, options, noMatchContext) {
	return (state) => {
		if (state == null) return {
			success: false,
			error: getNoMatchError(options, noMatchContext)
		};
		const [i, result] = state;
		if (result.success) return parsers[i].complete(result.next.state);
		return {
			success: false,
			error: result.error
		};
	};
}
/**
* Creates a suggest() method shared by or() and longestMatch().
* @internal
*/
function createExclusiveSuggest(parsers) {
	return (context, prefix) => {
		const suggestions = [];
		if (context.state == null) for (const parser of parsers) {
			const parserSuggestions = parser.suggest({
				...context,
				state: parser.initialState
			}, prefix);
			suggestions.push(...parserSuggestions);
		}
		else {
			const [index, parserResult] = context.state;
			if (parserResult.success) {
				const parserSuggestions = parsers[index].suggest({
					...context,
					state: parserResult.next.state
				}, prefix);
				suggestions.push(...parserSuggestions);
			}
		}
		return deduplicateSuggestions(suggestions);
	};
}
/**
* Gets the no-match error, either from custom options or default.
* Shared by or() and longestMatch().
* @internal
*/
function getNoMatchError(options, noMatchContext) {
	const customNoMatch = options?.errors?.noMatch;
	return customNoMatch ? typeof customNoMatch === "function" ? customNoMatch(noMatchContext) : customNoMatch : generateNoMatchError(noMatchContext);
}
/**
* Creates default error for parse() method when buffer is not empty.
* Shared by or() and longestMatch().
* @internal
*/
function createUnexpectedInputError(token, usage, options) {
	const defaultMsg = message`Unexpected option or subcommand: ${optionName(token)}.`;
	if (options?.errors?.unexpectedInput != null) return typeof options.errors.unexpectedInput === "function" ? options.errors.unexpectedInput(token) : options.errors.unexpectedInput;
	return createErrorWithSuggestions(defaultMsg, token, usage, "both", options?.errors?.suggestions);
}
/**
* @since 0.5.0
*/
function or(...args) {
	let parsers;
	let options;
	if (args.length > 0 && args[args.length - 1] && typeof args[args.length - 1] === "object" && !("$valueType" in args[args.length - 1])) {
		options = args[args.length - 1];
		parsers = args.slice(0, -1);
	} else {
		parsers = args;
		options = void 0;
	}
	const noMatchContext = analyzeNoMatchContext(parsers);
	return {
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: [{
			type: "exclusive",
			terms: parsers.map((p) => p.usage)
		}],
		initialState: void 0,
		complete: createExclusiveComplete(parsers, options, noMatchContext),
		parse(context) {
			let error = {
				consumed: 0,
				error: context.buffer.length < 1 ? getNoMatchError(options, noMatchContext) : createUnexpectedInputError(context.buffer[0], context.usage, options)
			};
			const orderedParsers = parsers.map((p, i) => [p, i]);
			orderedParsers.sort(([_, a], [__, b]) => context.state?.[0] === a ? -1 : context.state?.[0] === b ? 1 : a - b);
			for (const [parser, i] of orderedParsers) {
				const result = parser.parse({
					...context,
					state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
				});
				if (result.success && result.consumed.length > 0) {
					if (context.state?.[0] !== i && context.state?.[1].success) return {
						success: false,
						consumed: context.buffer.length - result.next.buffer.length,
						error: message`${values(context.state[1].consumed)} and ${values(result.consumed)} cannot be used together.`
					};
					return {
						success: true,
						next: {
							...context,
							buffer: result.next.buffer,
							optionsTerminated: result.next.optionsTerminated,
							state: [i, result]
						},
						consumed: result.consumed
					};
				} else if (!result.success && error.consumed < result.consumed) error = result;
			}
			return {
				...error,
				success: false
			};
		},
		suggest: createExclusiveSuggest(parsers),
		getDocFragments(state, _defaultValue) {
			let description;
			let fragments;
			if (state.kind === "unavailable" || state.state == null) fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }, void 0).fragments);
			else {
				const [index, parserResult] = state.state;
				const innerState = parserResult.success ? {
					kind: "available",
					state: parserResult.next.state
				} : { kind: "unavailable" };
				const docFragments = parsers[index].getDocFragments(innerState, void 0);
				description = docFragments.description;
				fragments = docFragments.fragments;
			}
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			return {
				description,
				fragments: [...sections.map((s) => ({
					...s,
					type: "section"
				})), {
					type: "section",
					entries
				}]
			};
		}
	};
}
/**
* @since 0.5.0
*/
function longestMatch(...args) {
	let parsers;
	let options;
	if (args.length > 0 && args[args.length - 1] && typeof args[args.length - 1] === "object" && !("$valueType" in args[args.length - 1])) {
		options = args[args.length - 1];
		parsers = args.slice(0, -1);
	} else {
		parsers = args;
		options = void 0;
	}
	const noMatchContext = analyzeNoMatchContext(parsers);
	return {
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: [{
			type: "exclusive",
			terms: parsers.map((p) => p.usage)
		}],
		initialState: void 0,
		complete: createExclusiveComplete(parsers, options, noMatchContext),
		parse(context) {
			let bestMatch = null;
			let error = {
				consumed: 0,
				error: context.buffer.length < 1 ? getNoMatchError(options, noMatchContext) : createUnexpectedInputError(context.buffer[0], context.usage, options)
			};
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				const result = parser.parse({
					...context,
					state: context.state == null || context.state[0] !== i || !context.state[1].success ? parser.initialState : context.state[1].next.state
				});
				if (result.success) {
					const consumed = context.buffer.length - result.next.buffer.length;
					if (bestMatch === null || consumed > bestMatch.consumed) bestMatch = {
						index: i,
						result,
						consumed
					};
				} else if (error.consumed < result.consumed) error = result;
			}
			if (bestMatch && bestMatch.result.success) return {
				success: true,
				next: {
					...context,
					buffer: bestMatch.result.next.buffer,
					optionsTerminated: bestMatch.result.next.optionsTerminated,
					state: [bestMatch.index, bestMatch.result]
				},
				consumed: bestMatch.result.consumed
			};
			return {
				...error,
				success: false
			};
		},
		suggest: createExclusiveSuggest(parsers),
		getDocFragments(state, _defaultValue) {
			let description;
			let footer;
			let fragments;
			if (state.kind === "unavailable" || state.state == null) fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }).fragments);
			else {
				const [i, result] = state.state;
				if (result.success) {
					const docResult = parsers[i].getDocFragments({
						kind: "available",
						state: result.next.state
					});
					description = docResult.description;
					footer = docResult.footer;
					fragments = docResult.fragments;
				} else fragments = parsers.flatMap((p) => p.getDocFragments({ kind: "unavailable" }).fragments);
			}
			return {
				description,
				fragments,
				footer
			};
		}
	};
}
function object(labelOrParsers, maybeParsersOrOptions, maybeOptions) {
	const label = typeof labelOrParsers === "string" ? labelOrParsers : void 0;
	let parsers;
	let options = {};
	if (typeof labelOrParsers === "string") {
		parsers = maybeParsersOrOptions;
		options = maybeOptions ?? {};
	} else {
		parsers = labelOrParsers;
		options = maybeParsersOrOptions ?? {};
	}
	const parserPairs = Object.entries(parsers);
	parserPairs.sort(([_, parserA], [__, parserB]) => parserB.priority - parserA.priority);
	if (!options.allowDuplicates) checkDuplicateOptionNames(parserPairs.map(([field, parser]) => [field, parser.usage]));
	const noMatchContext = analyzeNoMatchContext(Object.values(parsers));
	return {
		$valueType: [],
		$stateType: [],
		priority: Math.max(...Object.values(parsers).map((p) => p.priority)),
		usage: parserPairs.flatMap(([_, p]) => p.usage),
		initialState: Object.fromEntries(Object.entries(parsers).map(([key, parser]) => [key, parser.initialState])),
		parse(context) {
			let error = {
				consumed: 0,
				error: context.buffer.length > 0 ? (() => {
					const token = context.buffer[0];
					const customMessage = options.errors?.unexpectedInput;
					if (customMessage) return typeof customMessage === "function" ? customMessage(token) : customMessage;
					const baseError = message`Unexpected option or argument: ${token}.`;
					return createErrorWithSuggestions(baseError, token, context.usage, "both", options.errors?.suggestions);
				})() : (() => {
					const customEndOfInput = options.errors?.endOfInput;
					return customEndOfInput ? typeof customEndOfInput === "function" ? customEndOfInput(noMatchContext) : customEndOfInput : generateNoMatchError(noMatchContext);
				})()
			};
			let currentContext = context;
			let anySuccess = false;
			const allConsumed = [];
			let madeProgress = true;
			while (madeProgress && currentContext.buffer.length > 0) {
				madeProgress = false;
				for (const [field, parser] of parserPairs) {
					const result = parser.parse({
						...currentContext,
						state: currentContext.state && typeof currentContext.state === "object" && field in currentContext.state ? currentContext.state[field] : parser.initialState
					});
					if (result.success && result.consumed.length > 0) {
						currentContext = {
							...currentContext,
							buffer: result.next.buffer,
							optionsTerminated: result.next.optionsTerminated,
							state: {
								...currentContext.state,
								[field]: result.next.state
							}
						};
						allConsumed.push(...result.consumed);
						anySuccess = true;
						madeProgress = true;
						break;
					} else if (!result.success && error.consumed < result.consumed) error = result;
				}
			}
			if (anySuccess) return {
				success: true,
				next: currentContext,
				consumed: allConsumed
			};
			if (context.buffer.length === 0) {
				let allCanComplete = true;
				for (const [field, parser] of parserPairs) {
					const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
					const completeResult = parser.complete(fieldState);
					if (!completeResult.success) {
						allCanComplete = false;
						break;
					}
				}
				if (allCanComplete) return {
					success: true,
					next: context,
					consumed: []
				};
			}
			return {
				...error,
				success: false
			};
		},
		complete(state) {
			const result = {};
			for (const field in state) {
				if (!(field in parsers)) continue;
				const valueResult = parsers[field].complete(state[field]);
				if (valueResult.success) result[field] = valueResult.value;
				else return {
					success: false,
					error: valueResult.error
				};
			}
			return {
				success: true,
				value: result
			};
		},
		suggest(context, prefix) {
			const suggestions = [];
			if (context.buffer.length > 0) {
				const lastToken = context.buffer[context.buffer.length - 1];
				for (const [field, parser] of parserPairs) if (isOptionRequiringValue(parser.usage, lastToken)) {
					const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
					return Array.from(parser.suggest({
						...context,
						state: fieldState
					}, prefix));
				}
			}
			for (const [field, parser] of parserPairs) {
				const fieldState = context.state && typeof context.state === "object" && field in context.state ? context.state[field] : parser.initialState;
				const fieldSuggestions = parser.suggest({
					...context,
					state: fieldState
				}, prefix);
				suggestions.push(...fieldSuggestions);
			}
			return deduplicateSuggestions(suggestions);
		},
		getDocFragments(state, defaultValue) {
			const fragments = parserPairs.flatMap(([field, p]) => {
				const fieldState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[field]
				};
				return p.getDocFragments(fieldState, defaultValue?.[field]).fragments;
			});
			const entries = fragments.filter((d) => d.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const section = {
				title: label,
				entries
			};
			sections.push(section);
			return { fragments: sections.map((s) => ({
				...s,
				type: "section"
			})) };
		}
	};
}
function tuple(labelOrParsers, maybeParsersOrOptions, maybeOptions) {
	const label = typeof labelOrParsers === "string" ? labelOrParsers : void 0;
	let parsers;
	let options = {};
	if (typeof labelOrParsers === "string") {
		parsers = maybeParsersOrOptions;
		options = maybeOptions ?? {};
	} else {
		parsers = labelOrParsers;
		options = maybeParsersOrOptions ?? {};
	}
	if (!options.allowDuplicates) checkDuplicateOptionNames(parsers.map((parser, index) => [String(index), parser.usage]));
	return {
		$valueType: [],
		$stateType: [],
		usage: parsers.toSorted((a, b) => b.priority - a.priority).flatMap((p) => p.usage),
		priority: parsers.length > 0 ? Math.max(...parsers.map((p) => p.priority)) : 0,
		initialState: parsers.map((parser) => parser.initialState),
		parse(context) {
			let currentContext = context;
			const allConsumed = [];
			const matchedParsers = /* @__PURE__ */ new Set();
			while (matchedParsers.size < parsers.length) {
				let foundMatch = false;
				let error = {
					consumed: 0,
					error: message`No remaining parsers could match the input.`
				};
				const remainingParsers = parsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
				for (const [parser, index] of remainingParsers) {
					const result = parser.parse({
						...currentContext,
						state: currentContext.state[index]
					});
					if (result.success && result.consumed.length > 0) {
						currentContext = {
							...currentContext,
							buffer: result.next.buffer,
							optionsTerminated: result.next.optionsTerminated,
							state: currentContext.state.map((s, idx) => idx === index ? result.next.state : s)
						};
						allConsumed.push(...result.consumed);
						matchedParsers.add(index);
						foundMatch = true;
						break;
					} else if (!result.success && error.consumed < result.consumed) error = result;
				}
				if (!foundMatch) for (const [parser, index] of remainingParsers) {
					const result = parser.parse({
						...currentContext,
						state: currentContext.state[index]
					});
					if (result.success && result.consumed.length < 1) {
						currentContext = {
							...currentContext,
							state: currentContext.state.map((s, idx) => idx === index ? result.next.state : s)
						};
						matchedParsers.add(index);
						foundMatch = true;
						break;
					} else if (!result.success && result.consumed < 1) {
						matchedParsers.add(index);
						foundMatch = true;
						break;
					}
				}
				if (!foundMatch) return {
					...error,
					success: false
				};
			}
			return {
				success: true,
				next: currentContext,
				consumed: allConsumed
			};
		},
		complete(state) {
			const result = [];
			for (let i = 0; i < parsers.length; i++) {
				const valueResult = parsers[i].complete(state[i]);
				if (valueResult.success) result[i] = valueResult.value;
				else return {
					success: false,
					error: valueResult.error
				};
			}
			return {
				success: true,
				value: result
			};
		},
		suggest(context, prefix) {
			const suggestions = [];
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				const parserState = context.state && Array.isArray(context.state) ? context.state[i] : parser.initialState;
				const parserSuggestions = parser.suggest({
					...context,
					state: parserState
				}, prefix);
				suggestions.push(...parserSuggestions);
			}
			return deduplicateSuggestions(suggestions);
		},
		getDocFragments(state, defaultValue) {
			const fragments = parsers.flatMap((p, i) => {
				const indexState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[i]
				};
				return p.getDocFragments(indexState, defaultValue?.[i]).fragments;
			});
			const entries = fragments.filter((d) => d.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const section = {
				title: label,
				entries
			};
			sections.push(section);
			return { fragments: sections.map((s) => ({
				...s,
				type: "section"
			})) };
		},
		[Symbol.for("Deno.customInspect")]() {
			const parsersStr = parsers.length === 1 ? `[1 parser]` : `[${parsers.length} parsers]`;
			return label ? `tuple(${JSON.stringify(label)}, ${parsersStr})` : `tuple(${parsersStr})`;
		}
	};
}
function merge(...args) {
	const label = typeof args[0] === "string" ? args[0] : void 0;
	const lastArg = args[args.length - 1];
	const options = lastArg && typeof lastArg === "object" && !("parse" in lastArg) && !("complete" in lastArg) ? lastArg : {};
	const startIndex = typeof args[0] === "string" ? 1 : 0;
	const endIndex = lastArg && typeof lastArg === "object" && !("parse" in lastArg) && !("complete" in lastArg) ? args.length - 1 : args.length;
	const rawParsers = args.slice(startIndex, endIndex);
	const withIndex = rawParsers.map((p, i) => [p, i]);
	const sorted = withIndex.toSorted(([a], [b]) => b.priority - a.priority);
	const parsers = sorted.map(([p]) => p);
	if (!options.allowDuplicates) checkDuplicateOptionNames(sorted.map(([parser, originalIndex]) => [String(originalIndex), parser.usage]));
	const initialState = {};
	for (const parser of parsers) if (parser.initialState && typeof parser.initialState === "object") for (const field in parser.initialState) initialState[field] = parser.initialState[field];
	return {
		$valueType: [],
		$stateType: [],
		priority: Math.max(...parsers.map((p) => p.priority)),
		usage: parsers.flatMap((p) => p.usage),
		initialState,
		parse(context) {
			let zeroConsumedSuccess = null;
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				let parserState;
				if (parser.initialState === void 0) parserState = void 0;
				else if (parser.initialState && typeof parser.initialState === "object") if (context.state && typeof context.state === "object") {
					const extractedState = {};
					for (const field in parser.initialState) extractedState[field] = field in context.state ? context.state[field] : parser.initialState[field];
					parserState = extractedState;
				} else parserState = parser.initialState;
				else parserState = parser.initialState;
				const result = parser.parse({
					...context,
					state: parserState
				});
				if (result.success) {
					let newState;
					if (parser.initialState === void 0) {
						const key = `__parser_${i}`;
						if (result.consumed.length > 0 || result.next.state !== void 0) newState = {
							...context.state,
							[key]: result.next.state
						};
						else newState = { ...context.state };
					} else newState = {
						...context.state,
						...result.next.state
					};
					const newContext = {
						...context,
						buffer: result.next.buffer,
						optionsTerminated: result.next.optionsTerminated,
						state: newState
					};
					if (result.consumed.length > 0) return {
						success: true,
						next: newContext,
						consumed: result.consumed
					};
					context = newContext;
					if (zeroConsumedSuccess === null) zeroConsumedSuccess = {
						context: newContext,
						consumed: []
					};
					else zeroConsumedSuccess.context = newContext;
				} else if (result.consumed < 1) continue;
				else return result;
			}
			if (zeroConsumedSuccess !== null) return {
				success: true,
				next: zeroConsumedSuccess.context,
				consumed: zeroConsumedSuccess.consumed
			};
			return {
				success: false,
				consumed: 0,
				error: message`No matching option or argument found.`
			};
		},
		complete(state) {
			const object$1 = {};
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				let parserState;
				if (parser.initialState === void 0) {
					const key = `__parser_${i}`;
					if (state && typeof state === "object" && key in state) parserState = state[key];
					else parserState = void 0;
				} else if (parser.initialState && typeof parser.initialState === "object") if (state && typeof state === "object") {
					const extractedState = {};
					for (const field in parser.initialState) extractedState[field] = field in state ? state[field] : parser.initialState[field];
					parserState = extractedState;
				} else parserState = parser.initialState;
				else parserState = parser.initialState;
				const result = parser.complete(parserState);
				if (!result.success) return result;
				for (const field in result.value) object$1[field] = result.value[field];
			}
			return {
				success: true,
				value: object$1
			};
		},
		suggest(context, prefix) {
			const suggestions = [];
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				let parserState;
				if (parser.initialState === void 0) {
					const key = `__parser_${i}`;
					if (context.state && typeof context.state === "object" && key in context.state) parserState = context.state[key];
					else parserState = void 0;
				} else if (parser.initialState && typeof parser.initialState === "object") if (context.state && typeof context.state === "object") {
					const extractedState = {};
					for (const field in parser.initialState) extractedState[field] = field in context.state ? context.state[field] : parser.initialState[field];
					parserState = extractedState;
				} else parserState = parser.initialState;
				else parserState = parser.initialState;
				const parserSuggestions = parser.suggest({
					...context,
					state: parserState
				}, prefix);
				suggestions.push(...parserSuggestions);
			}
			return deduplicateSuggestions(suggestions);
		},
		getDocFragments(state, _defaultValue) {
			const fragments = parsers.flatMap((p) => {
				const parserState = p.initialState === void 0 ? { kind: "unavailable" } : state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state
				};
				return p.getDocFragments(parserState, void 0).fragments;
			});
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			if (label) {
				const labeledSection = {
					title: label,
					entries
				};
				sections.push(labeledSection);
				return { fragments: sections.map((s) => ({
					...s,
					type: "section"
				})) };
			}
			return { fragments: [...sections.map((s) => ({
				...s,
				type: "section"
			})), {
				type: "section",
				entries
			}] };
		}
	};
}
function concat(...parsers) {
	const initialState = parsers.map((parser) => parser.initialState);
	return {
		$valueType: [],
		$stateType: [],
		priority: parsers.length > 0 ? Math.max(...parsers.map((p) => p.priority)) : 0,
		usage: parsers.flatMap((p) => p.usage),
		initialState,
		parse(context) {
			let currentContext = context;
			const allConsumed = [];
			const matchedParsers = /* @__PURE__ */ new Set();
			while (matchedParsers.size < parsers.length) {
				let foundMatch = false;
				let error = {
					consumed: 0,
					error: message`No remaining parsers could match the input.`
				};
				const remainingParsers = parsers.map((parser, index) => [parser, index]).filter(([_, index]) => !matchedParsers.has(index)).sort(([parserA], [parserB]) => parserB.priority - parserA.priority);
				for (const [parser, index] of remainingParsers) {
					const result = parser.parse({
						...currentContext,
						state: currentContext.state[index]
					});
					if (result.success && result.consumed.length > 0) {
						currentContext = {
							...currentContext,
							buffer: result.next.buffer,
							optionsTerminated: result.next.optionsTerminated,
							state: currentContext.state.map((s, idx) => idx === index ? result.next.state : s)
						};
						allConsumed.push(...result.consumed);
						matchedParsers.add(index);
						foundMatch = true;
						break;
					} else if (!result.success && error.consumed < result.consumed) error = result;
				}
				if (!foundMatch) for (const [parser, index] of remainingParsers) {
					const result = parser.parse({
						...currentContext,
						state: currentContext.state[index]
					});
					if (result.success && result.consumed.length < 1) {
						currentContext = {
							...currentContext,
							state: currentContext.state.map((s, idx) => idx === index ? result.next.state : s)
						};
						matchedParsers.add(index);
						foundMatch = true;
						break;
					} else if (!result.success && result.consumed < 1) {
						matchedParsers.add(index);
						foundMatch = true;
						break;
					}
				}
				if (!foundMatch) return {
					...error,
					success: false
				};
			}
			return {
				success: true,
				next: currentContext,
				consumed: allConsumed
			};
		},
		complete(state) {
			const results = [];
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				const parserState = state[i];
				const result = parser.complete(parserState);
				if (!result.success) return result;
				if (Array.isArray(result.value)) results.push(...result.value);
				else results.push(result.value);
			}
			return {
				success: true,
				value: results
			};
		},
		suggest(context, prefix) {
			const suggestions = [];
			for (let i = 0; i < parsers.length; i++) {
				const parser = parsers[i];
				const parserState = context.state && Array.isArray(context.state) ? context.state[i] : parser.initialState;
				const parserSuggestions = parser.suggest({
					...context,
					state: parserState
				}, prefix);
				suggestions.push(...parserSuggestions);
			}
			return deduplicateSuggestions(suggestions);
		},
		getDocFragments(state, _defaultValue) {
			const fragments = parsers.flatMap((p, index) => {
				const indexState = state.kind === "unavailable" ? { kind: "unavailable" } : {
					kind: "available",
					state: state.state[index]
				};
				return p.getDocFragments(indexState, void 0).fragments;
			});
			const entries = fragments.filter((f) => f.type === "entry");
			const sections = [];
			for (const fragment of fragments) {
				if (fragment.type !== "section") continue;
				if (fragment.title == null) entries.push(...fragment.entries);
				else sections.push(fragment);
			}
			const result = [...sections.map((s) => ({
				...s,
				type: "section"
			}))];
			if (entries.length > 0) result.push({
				type: "section",
				entries
			});
			return { fragments: result };
		}
	};
}
/**
* Wraps a parser with a group label for documentation purposes.
*
* The `group()` function is a documentation-only wrapper that applies a label
* to any parser for help text organization. This allows you to use clean code
* structure with combinators like {@link merge} while maintaining well-organized
* help text through group labeling.
*
* The wrapped parser has identical parsing behavior but generates documentation
* fragments wrapped in a labeled section. This is particularly useful when
* combining parsers using {@link merge}â€”you can wrap the merged result with
* `group()` to add a section header in help output.
*
* @example
* ```typescript
* const apiOptions = merge(
*   object({ endpoint: option("--endpoint", string()) }),
*   object({ timeout: option("--timeout", integer()) })
* );
*
* const groupedApiOptions = group("API Options", apiOptions);
* // Now produces a labeled "API Options" section in help text
* ```
*
* @example
* ```typescript
* // Can be used with any parser, not just merge()
* const verboseGroup = group("Verbosity", object({
*   verbose: option("-v", "--verbose"),
*   quiet: option("-q", "--quiet")
* }));
* ```
*
* @template TValue The value type of the wrapped parser.
* @template TState The state type of the wrapped parser.
* @param label A descriptive label for this parser group, used for
*              documentation and help text organization.
* @param parser The parser to wrap with a group label.
* @returns A new parser that behaves identically to the input parser
*          but generates documentation within a labeled section.
* @since 0.4.0
*/
function group(label, parser) {
	return {
		$valueType: parser.$valueType,
		$stateType: parser.$stateType,
		priority: parser.priority,
		usage: parser.usage,
		initialState: parser.initialState,
		parse: (context) => parser.parse(context),
		complete: (state) => parser.complete(state),
		suggest: (context, prefix) => parser.suggest(context, prefix),
		getDocFragments: (state, defaultValue) => {
			const { description, fragments } = parser.getDocFragments(state, defaultValue);
			const allEntries = [];
			const titledSections = [];
			for (const fragment of fragments) if (fragment.type === "entry") allEntries.push(fragment);
			else if (fragment.type === "section") if (fragment.title) titledSections.push(fragment);
			else allEntries.push(...fragment.entries);
			const labeledSection = {
				title: label,
				entries: allEntries
			};
			return {
				description,
				fragments: [...titledSections.map((s) => ({
					...s,
					type: "section"
				})), {
					type: "section",
					...labeledSection
				}]
			};
		}
	};
}
/**
* Creates a conditional parser that selects different branch parsers based on
* a discriminator option value. This enables discriminated union patterns where
* certain options are only required or available when a specific discriminator
* value is selected.
*
* The result type is a tuple: `[discriminatorValue, branchResult]`
*
* @example
* ```typescript
* // Basic conditional parsing
* const parser = conditional(
*   option("--reporter", choice(["console", "junit"])),
*   {
*     console: object({}),
*     junit: object({ outputFile: option("--output-file", string()) }),
*   },
*   object({}) // default when --reporter is not provided
* );
*
* const result = parse(parser, ["--reporter", "junit", "--output-file", "out.xml"]);
* // result.value = ["junit", { outputFile: "out.xml" }]
*
* // Without --reporter, uses default branch:
* const defaultResult = parse(parser, []);
* // defaultResult.value = [undefined, {}]
* ```
*
* @since 0.8.0
*/
function conditional(discriminator, branches, defaultBranch, options) {
	const branchParsers = Object.entries(branches);
	const allBranchParsers = defaultBranch ? [...branchParsers.map(([_, p]) => p), defaultBranch] : branchParsers.map(([_, p]) => p);
	const maxPriority = Math.max(discriminator.priority, ...allBranchParsers.map((p) => p.priority));
	function appendLiteralToUsage(usage$1, literalValue) {
		const result = [];
		for (const term of usage$1) if (term.type === "option" && term.metavar !== void 0) {
			const { metavar: _,...optionWithoutMetavar } = term;
			result.push(optionWithoutMetavar);
			result.push({
				type: "literal",
				value: literalValue
			});
		} else if (term.type === "optional") result.push({
			...term,
			terms: appendLiteralToUsage(term.terms, literalValue)
		});
		else if (term.type === "multiple") result.push({
			...term,
			terms: appendLiteralToUsage(term.terms, literalValue)
		});
		else if (term.type === "exclusive") result.push({
			...term,
			terms: term.terms.map((t) => appendLiteralToUsage(t, literalValue))
		});
		else result.push(term);
		return result;
	}
	const branchUsages = branchParsers.map(([key, p]) => [...appendLiteralToUsage(discriminator.usage, key), ...p.usage]);
	if (defaultBranch) branchUsages.push(defaultBranch.usage);
	const usage = branchUsages.length > 1 ? [{
		type: "exclusive",
		terms: branchUsages
	}] : branchUsages[0] ?? [];
	const initialState = {
		discriminatorState: discriminator.initialState,
		discriminatorValue: void 0,
		selectedBranch: void 0,
		branchState: void 0
	};
	return {
		$valueType: [],
		$stateType: [],
		priority: maxPriority,
		usage,
		initialState,
		parse(context) {
			const state = context.state ?? initialState;
			if (state.selectedBranch !== void 0) {
				const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
				const branchResult = branchParser.parse({
					...context,
					state: state.branchState,
					usage: branchParser.usage
				});
				if (branchResult.success) return {
					success: true,
					next: {
						...branchResult.next,
						state: {
							...state,
							branchState: branchResult.next.state
						}
					},
					consumed: branchResult.consumed
				};
				return branchResult;
			}
			const discriminatorResult = discriminator.parse({
				...context,
				state: state.discriminatorState
			});
			if (discriminatorResult.success && discriminatorResult.consumed.length > 0) {
				const completionResult = discriminator.complete(discriminatorResult.next.state);
				if (completionResult.success) {
					const value = completionResult.value;
					const branchParser = branches[value];
					if (branchParser) {
						const branchParseResult = branchParser.parse({
							...context,
							buffer: discriminatorResult.next.buffer,
							optionsTerminated: discriminatorResult.next.optionsTerminated,
							state: branchParser.initialState,
							usage: branchParser.usage
						});
						if (branchParseResult.success) return {
							success: true,
							next: {
								...branchParseResult.next,
								state: {
									discriminatorState: discriminatorResult.next.state,
									discriminatorValue: value,
									selectedBranch: {
										kind: "branch",
										key: value
									},
									branchState: branchParseResult.next.state
								}
							},
							consumed: [...discriminatorResult.consumed, ...branchParseResult.consumed]
						};
						return {
							success: true,
							next: {
								...discriminatorResult.next,
								state: {
									discriminatorState: discriminatorResult.next.state,
									discriminatorValue: value,
									selectedBranch: {
										kind: "branch",
										key: value
									},
									branchState: branchParser.initialState
								}
							},
							consumed: discriminatorResult.consumed
						};
					}
				}
			}
			if (defaultBranch !== void 0) {
				const defaultResult = defaultBranch.parse({
					...context,
					state: state.branchState ?? defaultBranch.initialState,
					usage: defaultBranch.usage
				});
				if (defaultResult.success && defaultResult.consumed.length > 0) return {
					success: true,
					next: {
						...defaultResult.next,
						state: {
							...state,
							selectedBranch: { kind: "default" },
							branchState: defaultResult.next.state
						}
					},
					consumed: defaultResult.consumed
				};
			}
			const noMatchContext = analyzeNoMatchContext([discriminator, ...allBranchParsers]);
			const errorMessage = options?.errors?.noMatch ? typeof options.errors.noMatch === "function" ? options.errors.noMatch(noMatchContext) : options.errors.noMatch : generateNoMatchError(noMatchContext);
			return {
				success: false,
				consumed: 0,
				error: errorMessage
			};
		},
		complete(state) {
			if (state.selectedBranch === void 0) {
				if (defaultBranch !== void 0) {
					const branchState = state.branchState ?? defaultBranch.initialState;
					const defaultResult = defaultBranch.complete(branchState);
					if (!defaultResult.success) return defaultResult;
					return {
						success: true,
						value: [void 0, defaultResult.value]
					};
				}
				return {
					success: false,
					error: message`Missing required discriminator option.`
				};
			}
			const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
			const branchResult = branchParser.complete(state.branchState);
			if (!branchResult.success) {
				if (state.discriminatorValue !== void 0 && options?.errors?.branchError) return {
					success: false,
					error: options.errors.branchError(state.discriminatorValue, branchResult.error)
				};
				return branchResult;
			}
			const discriminatorValue = state.selectedBranch.kind === "default" ? void 0 : state.selectedBranch.key;
			return {
				success: true,
				value: [discriminatorValue, branchResult.value]
			};
		},
		suggest(context, prefix) {
			const state = context.state ?? initialState;
			const suggestions = [];
			if (state.selectedBranch === void 0) {
				suggestions.push(...discriminator.suggest({
					...context,
					state: state.discriminatorState
				}, prefix));
				if (defaultBranch !== void 0) suggestions.push(...defaultBranch.suggest({
					...context,
					state: state.branchState ?? defaultBranch.initialState
				}, prefix));
			} else {
				const branchParser = state.selectedBranch.kind === "default" ? defaultBranch : branches[state.selectedBranch.key];
				suggestions.push(...branchParser.suggest({
					...context,
					state: state.branchState
				}, prefix));
			}
			return deduplicateSuggestions(suggestions);
		},
		getDocFragments(_state, _defaultValue) {
			const fragments = [];
			const discriminatorFragments = discriminator.getDocFragments({ kind: "unavailable" }, void 0);
			fragments.push(...discriminatorFragments.fragments);
			for (const [key, branchParser] of branchParsers) {
				const branchFragments = branchParser.getDocFragments({ kind: "unavailable" }, void 0);
				const entries = branchFragments.fragments.filter((f) => f.type === "entry");
				for (const fragment of branchFragments.fragments) if (fragment.type === "section") entries.push(...fragment.entries);
				if (entries.length > 0) fragments.push({
					type: "section",
					title: `Options when ${key}`,
					entries
				});
			}
			if (defaultBranch !== void 0) {
				const defaultFragments = defaultBranch.getDocFragments({ kind: "unavailable" }, void 0);
				const entries = defaultFragments.fragments.filter((f) => f.type === "entry");
				for (const fragment of defaultFragments.fragments) if (fragment.type === "section") entries.push(...fragment.entries);
				if (entries.length > 0) fragments.push({
					type: "section",
					title: "Default options",
					entries
				});
			}
			return { fragments };
		}
	};
}

//#endregion
export { DuplicateOptionError, concat, conditional, group, longestMatch, merge, object, or, tuple };